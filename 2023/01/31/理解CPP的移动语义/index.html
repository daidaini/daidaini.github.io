<!DOCTYPE html>
<html lang=zh>
<head>
  <meta charset="utf-8">
  
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no, minimal-ui">
  <meta name="renderer" content="webkit">
  <meta http-equiv="Cache-Control" content="no-transform" />
  <meta http-equiv="Cache-Control" content="no-siteapp" />
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black">
  <meta name="format-detection" content="telephone=no,email=no,adress=no">
  <!-- Color theme for statusbar -->
  <meta name="theme-color" content="#000000" />
  <!-- 强制页面在当前窗口以独立页面显示,防止别人在框架里调用页面 -->
  <meta http-equiv="window-target" content="_top" />
  
  
  <title>理解CPP的移动语义 | daidaini&#39;s blogs</title>
  <meta name="description" content="什么是移动语义移动语义是从C++11标准开始支持的，那什么是移动语义呢？ 先引用下《Effective Modern C++》中关于移动语义的说明  Move semantics makes it possible for compilers to replace expensive copying operations with less expensive moves. In the same">
<meta property="og:type" content="article">
<meta property="og:title" content="理解CPP的移动语义">
<meta property="og:url" content="https://daidaini.github.io/2023/01/31/%E7%90%86%E8%A7%A3CPP%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="什么是移动语义移动语义是从C++11标准开始支持的，那什么是移动语义呢？ 先引用下《Effective Modern C++》中关于移动语义的说明  Move semantics makes it possible for compilers to replace expensive copying operations with less expensive moves. In the same">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-01-30T16:00:00.000Z">
<meta property="article:modified_time" content="2023-01-31T10:16:12.167Z">
<meta property="article:author" content="daidaini">
<meta property="article:tag" content="C++特性">
<meta name="twitter:card" content="summary">
  <!-- Canonical links -->
  <link rel="canonical" href="https://daidaini.github.io/2023/01/31/%E7%90%86%E8%A7%A3CPP%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/index.html">
  
    <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">
  
  
    <link rel="icon" href="favicon.png" type="image/x-icon">
  
  
<link rel="stylesheet" href="/css/style.css">

  
  
  
  
<meta name="generator" content="Hexo 5.4.0"></head>


<body class="main-center theme-green# 主题颜色 theme-black theme-blue theme-green theme-purple" itemscope itemtype="http://schema.org/WebPage">
  <header class="header" itemscope itemtype="http://schema.org/WPHeader">
  <div class="slimContent">
    <div class="navbar-header">
      
      
      <div class="profile-block text-center">
        <a id="avatar" href="https://github.com/daidaini" target="_blank">
          <img class="img-circle img-rotate" src="/images/girl.webp" width="200" height="200">
        </a>
        <h2 id="name" class="hidden-xs hidden-sm">daidaini</h2>
        <h3 id="title" class="hidden-xs hidden-sm hidden-md">一个底层程序员</h3>
        <small id="location" class="text-muted hidden-xs hidden-sm"><i class="icon icon-map-marker"></i> shanghai, China</small>
      </div>
      
      <div class="search" id="search-form-wrap">

    <form class="search-form sidebar-form">
        <div class="input-group">
            <input type="text" class="search-form-input form-control" placeholder="搜索" />
            <span class="input-group-btn">
                <button type="submit" class="search-form-submit btn btn-flat" onclick="return false;"><i class="icon icon-search"></i></button>
            </span>
        </div>
    </form>
    <div class="ins-search">
  <div class="ins-search-mask"></div>
  <div class="ins-search-container">
    <div class="ins-input-wrapper">
      <input type="text" class="ins-search-input" placeholder="想要查找什么..." x-webkit-speech />
      <button type="button" class="close ins-close ins-selectable" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">×</span></button>
    </div>
    <div class="ins-section-wrapper">
      <div class="ins-section-container"></div>
    </div>
  </div>
</div>


</div>
      <button class="navbar-toggle collapsed" type="button" data-toggle="collapse" data-target="#main-navbar" aria-controls="main-navbar" aria-expanded="false">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
    </div>
    <nav id="main-navbar" class="collapse navbar-collapse" itemscope itemtype="http://schema.org/SiteNavigationElement" role="navigation">
      <ul class="nav navbar-nav main-nav menu-highlight">
        
        
        <li class="menu-item menu-item-home">
          <a href="/.">
            
            <i class="icon icon-home-fill"></i>
            
            <span class="menu-title">首页</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-archives">
          <a href="/archives">
            
            <i class="icon icon-archives-fill"></i>
            
            <span class="menu-title">归档</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-categories">
          <a href="/categories">
            
            <i class="icon icon-folder"></i>
            
            <span class="menu-title">分类</span>
          </a>
        </li>
        
        
        <li class="menu-item menu-item-repository">
          <a href="/repository">
            
            <i class="icon icon-project"></i>
            
            <span class="menu-title">项目</span>
          </a>
        </li>
        
      </ul>
      
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/daidaini" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    </nav>
  </div>
</header>

  
    <aside class="sidebar" itemscope itemtype="http://schema.org/WPSideBar">
  <div class="slimContent">
    
      <div class="widget">
    <h3 class="widget-title">公告</h3>
    <div class="widget-body">
        <div id="board">
            <div class="content">
                <p>欢迎交流与分享自己的经验!<br>无论生活还是工作还是学习还是编程!</p>
            </div>
        </div>
    </div>
</div>

    
      
  <div class="widget">
    <h3 class="widget-title">标签</h3>
    <div class="widget-body">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/" rel="tag">C++标准库</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E7%89%B9%E6%80%A7/" rel="tag">C++特性</a><span class="tag-list-count">2</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C%E8%AF%AD%E8%A8%80/" rel="tag">C语言</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AC%94%E8%AE%B0/" rel="tag">笔记</a><span class="tag-list-count">3</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">标签云</h3>
    <div class="widget-body tagcloud">
      <a href="/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/" style="font-size: 13.5px;">C++标准库</a> <a href="/tags/C-%E7%89%B9%E6%80%A7/" style="font-size: 13.5px;">C++特性</a> <a href="/tags/C%E8%AF%AD%E8%A8%80/" style="font-size: 13px;">C语言</a> <a href="/tags/%E7%AC%94%E8%AE%B0/" style="font-size: 14px;">笔记</a>
    </div>
  </div>

    
      
  <div class="widget">
    <h3 class="widget-title">归档</h3>
    <div class="widget-body">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/01/">一月 2023</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">七月 2021</a><span class="archive-list-count">2</span></li></ul>
    </div>
  </div>


    
      
  <div class="widget">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget-body">
      <ul class="recent-post-list list-unstyled no-thumbnail">
        
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/31/%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3/" class="title">C指针的理解</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-30T16:00:00.000Z" itemprop="datePublished">2023-01-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a>
              </p>
              <p class="item-title">
                <a href="/2023/01/31/%E7%90%86%E8%A7%A3CPP%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" class="title">理解CPP的移动语义</a>
              </p>
              <p class="item-date">
                <time datetime="2023-01-30T16:00:00.000Z" itemprop="datePublished">2023-01-31</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a>
              </p>
              <p class="item-title">
                <a href="/2022/03/23/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/" class="title">常用Linux命令</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-23T13:14:28.000Z" itemprop="datePublished">2022-03-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a>
              </p>
              <p class="item-title">
                <a href="/2022/03/23/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/" class="title">Linux多线程服务端编程</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-23T12:50:22.000Z" itemprop="datePublished">2022-03-23</time>
              </p>
            </div>
          </li>
          
          <li>
            
            <div class="item-inner">
              <p class="item-category">
                <a class="category-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a>
              </p>
              <p class="item-title">
                <a href="/2022/03/23/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/" class="title">初始化列表</a>
              </p>
              <p class="item-date">
                <time datetime="2022-03-23T12:50:22.000Z" itemprop="datePublished">2022-03-23</time>
              </p>
            </div>
          </li>
          
      </ul>
    </div>
  </div>
  

    
  </div>
</aside>

  
  
<main class="main" role="main">
  <div class="content">
  <article id="post-理解CPP的移动语义" class="article article-type-post" itemscope itemtype="http://schema.org/BlogPosting">
    
    <div class="article-header">
      
        
  
    <h1 class="article-title" itemprop="name">
      理解CPP的移动语义
    </h1>
  

      
      <div class="article-meta">
        <span class="article-date">
    <i class="icon icon-calendar-check"></i>
	<a href="/2023/01/31/%E7%90%86%E8%A7%A3CPP%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" class="article-date">
	  <time datetime="2023-01-30T16:00:00.000Z" itemprop="datePublished">2023-01-31</time>
	</a>
</span>
        
  <span class="article-category">
    <i class="icon icon-folder"></i>
    <a class="article-category-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a>
  </span>

        
  <span class="article-tag">
    <i class="icon icon-tags"></i>
	<a class="article-tag-link-link" href="/tags/C-%E7%89%B9%E6%80%A7/" rel="tag">C++特性</a>
  </span>


        

        <span class="post-comment"><i class="icon icon-comment"></i> <a href="/2023/01/31/%E7%90%86%E8%A7%A3CPP%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/#comments" class="article-comment-link">评论</a></span>
        
      </div>
    </div>
    <div class="article-entry marked-body" itemprop="articleBody">
      
        <h2 id="什么是移动语义"><a href="#什么是移动语义" class="headerlink" title="什么是移动语义"></a>什么是移动语义</h2><p>移动语义是从C++11标准开始支持的，那什么是移动语义呢？</p>
<p>先引用下《Effective Modern C++》中关于移动语义的说明</p>
<blockquote>
<p>Move semantics makes it possible for compilers to replace expensive copying operations with less expensive moves. In the same way that copy constructors and copy assignment operators give you control over what it means to copy objects, move constructors and move assignment operators offer control over the semantics of moving. Move semantics also enables the creation of move-only types, such as std::unique_ptr, std::future, and std::thread.</p>
</blockquote>
<p>提取下关键信息就是：移动语义让编译器在需要拷贝对象时可以使用一种代价更低的移动的方式来执行。拷贝对象是通过拷贝构造和拷贝赋值，移动对象是通过移动构造和移动赋值。此外，移动语义还可以处理只能移动的对象的构造。</p>
<p>以下为个人理解：<br>移动语义的直接作用对象是函数的参数，发生移动的最直接的场景就是对自定义类型的参数进行传递的时候。<br>当参数是作为右值形式进行传递时，会调用该类型的移动构造函数(或移动赋值)以构造临时对象，举例说明。  </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">  <span class="built_in">A</span>() = <span class="keyword">default</span>;</span><br><span class="line">  <span class="built_in">A</span>(A&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;using move construct.\n&quot;</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	A&amp; <span class="keyword">operator</span>=(A&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;using move assign.\n&quot;</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(A param)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;using func.\n&quot;</span>;</span><br><span class="line">  A a1;</span><br><span class="line">	a1 = std::<span class="built_in">move</span>(param);  <span class="comment">//调用移动赋值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	A a;</span><br><span class="line">	<span class="comment">// func(a); //error. </span></span><br><span class="line">	<span class="built_in">func</span>(std::<span class="built_in">move</span>(a)); <span class="comment">//通过移动构造构建临时对象</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">using move construct.</span><br><span class="line">using func...</span><br><span class="line">using move assign.</span><br></pre></td></tr></table></figure>
<p>例子解释：</p>
<ul>
<li>A(A&amp;&amp; rhs) 这是移动构造函数的声明方式</li>
<li>A&amp; operator=(A&amp;&amp; rhs) 这是移动赋值函数的声明方式</li>
<li>std::move(param) 使用std::move可以将参数强制转换为右值形式。</li>
<li>func函数是使用值传递的方式，因此传参时会构造临时对象，由于参数转为了右值类型，因此会调用移动构造方法(打印了using move construct)</li>
<li>不能直接使用func(a)，因为在显示声明了移动构造函数后，编译器就不会自动生成拷贝构造函数了</li>
</ul>
<p>可见，虽然上述例子是最简单的使用移动语义的场景，但依然会不可避免的涉及到几个概念的理解：</p>
<ol>
<li><strong>左值和右值怎么区分</strong></li>
<li><strong>移动构造函数以及移动赋值函数</strong></li>
<li><strong>std::move强转右值，std::forward完美转发</strong></li>
</ol>
<p>我们可能还会考虑一个问题，<strong>函数传参除了值传递，还有引用传递，引用传递有单引用也有双引用，除了引用传递，此外还有使用指针传递，这些传递方式在移动语义的表现上都有什么区别呢？</strong></p>
<hr>
<h2 id="移动拷贝和移动赋值"><a href="#移动拷贝和移动赋值" class="headerlink" title="移动拷贝和移动赋值"></a>移动拷贝和移动赋值</h2><p>对于移动拷贝函数和移动赋值函数，其实上边的例子已经有简单的说明，其形式就是：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">A</span>(A&amp;&amp; rhs)</span><br><span class="line">A&amp; <span class="keyword">operator</span>=(A&amp;&amp; rhs)</span><br></pre></td></tr></table></figure>
<p>移动和拷贝的最大区别在于实现，拷贝要么就是深拷贝要么就是浅拷贝，而移动就真的就是移动掉了，不存在拷贝。它们的开销代价也因此而来。<br>举一个例子说明：</p>
<p>写一个MyString类，为简单阐述，只实现了拷贝赋值和移动赋值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyString</span> <span class="keyword">final</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="built_in">MyString</span>() &#123;</span><br><span class="line">		data_ = <span class="keyword">new</span> <span class="keyword">char</span>[<span class="number">1024</span>];</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">MyString</span>() &#123;</span><br><span class="line">		<span class="keyword">if</span> (data_ != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">delete</span> data_;</span><br><span class="line">			data_ = <span class="literal">nullptr</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">  MyString&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> MyString&amp; rhs)&#123;</span><br><span class="line">		<span class="keyword">if</span> (rhs.data_ == <span class="literal">nullptr</span> || data_ == <span class="literal">nullptr</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;copy assigning..\n&quot;</span>;</span><br><span class="line">		::<span class="built_in">memcpy</span>(<span class="keyword">this</span>-&gt;data_, rhs.data_, <span class="number">1024</span>);</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  MyString&amp; <span class="keyword">operator</span>=(MyString&amp;&amp; rhs) <span class="keyword">noexcept</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (rhs.data_ == <span class="literal">nullptr</span> || data_ == <span class="literal">nullptr</span>)</span><br><span class="line">			<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;move assigning..\n&quot;</span>;</span><br><span class="line">		data_ = rhs.data_;</span><br><span class="line">		rhs.data_ = <span class="literal">nullptr</span>;</span><br><span class="line">		<span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Empty</span><span class="params">()</span> <span class="keyword">const</span></span>&#123;</span><br><span class="line">		<span class="keyword">return</span> data_ == <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">char</span>* data_ = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个类，目的是在拷贝赋值时是深拷贝，在移动赋值时仅仅是移动，通过测试函数进行验证</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  MyString s1;</span><br><span class="line">  MyString s2;</span><br><span class="line">  s1 = s2;</span><br><span class="line">  <span class="built_in">assert</span>(!s2.<span class="built_in">Empty</span>());</span><br><span class="line">  s1 = std::<span class="built_in">move</span>(s2); </span><br><span class="line">  <span class="built_in">assert</span>(s2.<span class="built_in">Empty</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">copy assigning..</span><br><span class="line">move assigning..</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="左值右值"><a href="#左值右值" class="headerlink" title="左值右值"></a>左值右值</h2><h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>左值右值的概念可以总结概括为：</p>
<ul>
<li>左值指表达式结束后依然存在的持久对象，可以取到地址，比如具名变量或者对象实例</li>
<li>右值是表达式结束后就不再存在的临时对象，不可以取到地址，没有名字</li>
</ul>
<p>所以区分是左值还是右值，一个最有用的步骤即使看能否取到它的地址，如果可以就是左值，不可以则通常是一个右值。<br>此外，概念上来说，右值通常就是从方法中返回的临时对象（非绝对），而左值对应的就是实际可以指向的对象，不管是通过指针还是引用的形式。</p>
<p>右值还可以细分为纯右值(pure rvalue)和将亡值(expiring value)。</p>
<ul>
<li>纯右值：<ul>
<li>非引用返回的临时变量 </li>
<li>运算表达式产生的临时变量</li>
<li>原始字面量</li>
<li>lambda表达式</li>
</ul>
</li>
<li>将亡值：可以理解为将要被销毁，但是可以被移动的值</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp; vec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="comment">//此处expiring就是一个将亡值</span></span><br><span class="line">  <span class="comment">//因为std::string 对象可以移动，因此最后会调用移动赋值函数将expiring的值移动到str中</span></span><br><span class="line">  std::vector&lt;<span class="keyword">int</span>&gt; expiring&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line">  vec = std::<span class="built_in">move</span>(expiring);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="右值引用"><a href="#右值引用" class="headerlink" title="右值引用"></a>右值引用</h3><p>使用符号&amp;&amp; 表示右值引用。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">int</span> &amp;&amp;r1 = std::<span class="built_in">move</span>(a);</span><br><span class="line"><span class="comment">//int &amp;&amp;r1 = a; //error! </span></span><br></pre></td></tr></table></figure>
<p>但是使用带&amp;&amp;的类型表示的变量，不一定就是右值，按照左值的定义，只要具名的能取到地址的变量就是左值，所以即使你使用&amp;&amp;来声明，该是左值的还是左值。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(<span class="keyword">int</span>&amp;&amp; param)</span> </span>&#123;</span><br><span class="line">	<span class="comment">//int&amp;&amp; r1 = param; //error! param是左值!</span></span><br><span class="line">	<span class="keyword">int</span>&amp;&amp; r1 = std::<span class="built_in">move</span>(param);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>此外，有一种特殊情况，《Effective Modern C++》中将其称为 **universal references(通用引用)**，<br>看几个示例:</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; param)</span></span>; <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt;&amp;&amp; vec1 = std::vector&lt;<span class="keyword">int</span>&gt;&#123;&#125;; <span class="comment">//右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span>&amp;&amp; vec2 = vec1;   <span class="comment">//非右值引用</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(std::vector&lt;T&gt;&amp;&amp; param)</span></span>;  <span class="comment">//右值引用，不是T&amp;&amp;的形式，不是universal reference</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span>    <span class="comment">//非右值引用</span></span></span><br></pre></td></tr></table></figure>
<p>首先，universal reference必须是 T&amp;&amp; 的形式，且必须存在类型推导。<br>以上两个非右值引用的场景是最典型的两个universal references的场景。  </p>
<p>至于universal reference怎么判断是左值引用还是右值引用，需要进一步看它的构造者(即实际的传参)，如下示例： </p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func</span><span class="params">(T&amp;&amp; param)</span></span>; <span class="comment">//param是一个 universal reference</span></span><br><span class="line"></span><br><span class="line">std::vector&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line"><span class="built_in">func</span>(vec);    <span class="comment">//传参是左值，所以T&amp;&amp;对应的是左值引用 std::vector&lt;int&gt;&amp;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">func</span>(std::<span class="built_in">move</span>(vec)); <span class="comment">//传参是右值，所以param的类型是 std::vector&lt;int&gt;&amp;&amp;</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h2><p>先明确，对于性能而言，纯C指针的性能肯定是没话说的，即使移动语义可以减少一些消耗，但还是不能完全达到C指针直接操作内存的效率。<br>但也需要明确，C指针的不安全性，是很多复杂问题的根源，标准库引入了各种智能指针，其实就是在提供方法尽量避免使用裸C指针。<br>移动语义的引入，在我看来是想在安全性和性能之间找到一种尽可能的平衡。</p>
<p>区分了左值右值，也知道了移动构造和移动赋值的作用，那移动语义我们平时怎么去应用呢？<br>其实，现在的标准库中，基本上所有的容器都已经了支持移动语义，再配合现代编译器普遍支持的RVO机制，我们可以更简洁明确的编写代码，而不用使用指针或者左值引用来既表示出参，又表示入参。</p>
<h3 id="一个简单的队列的示例"><a href="#一个简单的队列的示例" class="headerlink" title="一个简单的队列的示例"></a>一个简单的队列的示例</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">DemoQueue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">(T&amp;&amp; task)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		tasks_.<span class="built_in">push</span>(std::<span class="built_in">move</span>(task));	</span><br><span class="line">		<span class="comment">//T&amp;&amp; task 模板展开后就不再需要自动推导，所以不是universal reference</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function">T <span class="title">Get</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		T t = std::<span class="built_in">move</span>(tasks_.<span class="built_in">front</span>()); <span class="comment">//front()返回的是左值引用，由于该元素后续会被移除(pop)，属于将亡值</span></span><br><span class="line">		tasks_.<span class="built_in">pop</span>();</span><br><span class="line">		<span class="keyword">return</span> t;  <span class="comment">//RVO 返回时不会再拷贝临时对象</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	std::queue&lt;T&gt; tasks_;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	TaskQueue&lt;std::string&gt; q1;</span><br><span class="line">	q1.<span class="built_in">Insert</span>(<span class="string">&quot;first&quot;</span>s);</span><br><span class="line">	q1.<span class="built_in">Insert</span>(<span class="string">&quot;second&quot;</span>s);	</span><br><span class="line">	q1.<span class="built_in">Insert</span>(<span class="string">&quot;third&quot;</span>s);</span><br><span class="line"></span><br><span class="line">	<span class="built_in">assert</span>(q1.<span class="built_in">Get</span>() == <span class="string">&quot;first&quot;</span>);</span><br><span class="line">	<span class="built_in">assert</span>(q1.<span class="built_in">Get</span>() == <span class="string">&quot;second&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="完美转发和通用引用"><a href="#完美转发和通用引用" class="headerlink" title="完美转发和通用引用"></a>完美转发和通用引用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintMerge</span><span class="params">(T&amp;&amp; a, T&amp;&amp; b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; std::forward&lt;T&gt;(a) + std::forward&lt;T&gt;(b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Test</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">20</span>;</span><br><span class="line">	<span class="built_in">PrintMerge</span>(a, b);		<span class="comment">//这里传参为左值</span></span><br><span class="line">	std::string s1&#123; <span class="string">&quot;one &quot;</span> &#125;;</span><br><span class="line">	std::string s2&#123; <span class="string">&quot;two &quot;</span> &#125;;</span><br><span class="line">	<span class="built_in">PrintMerge</span>(std::<span class="built_in">move</span>(s1), std::<span class="built_in">move</span>(s2));	<span class="comment">//这里传参为右值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>概括言之，std::forward完美转发的作用，就是把参数的实际类型左值还是右值引用继续传递下去。</p>

      
    </div>
    <div class="article-footer">
      <blockquote class="mt-2x">
  <ul class="post-copyright list-unstyled">
    
    <li class="post-copyright-link hidden-xs">
      <strong>本文链接：</strong>
      <a href="https://daidaini.github.io/2023/01/31/%E7%90%86%E8%A7%A3CPP%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/" title="理解CPP的移动语义" target="_blank" rel="external">https://daidaini.github.io/2023/01/31/理解CPP的移动语义/</a>
    </li>
    
    <li class="post-copyright-license">
      <strong>版权声明： </strong> 本博客所有文章除特别声明外，均采用 
      <a href="http://creativecommons.org/licenses/by/4.0/deed.zh" target="_blank" rel="external">CC BY 4.0 CN协议</a> 
      许可协议。转载请注明出处！
    </li>
  </ul>
</blockquote>


<div class="panel panel-default panel-badger">
  <div class="panel-body">
    <figure class="media">
      <div class="media-left">
        <a href="https://github.com/daidaini" target="_blank" class="img-burn thumb-sm visible-lg">
          <img src="/images/girl.webp" class="img-rounded w-full" alt="">
        </a>
      </div>
      <div class="media-body">
        <h3 class="media-heading"><a href="https://github.com/daidaini" target="_blank"><span class="text-dark">daidaini</span><small class="ml-1x">一个底层程序员</small></a></h3>
        <div>懂的不多，正在学习...</div>
      </div>
    </figure>
  </div>
</div>


    </div>
  </article>
  
    
  <section id="comments">
  	
  </section>


  
</div>

  <nav class="bar bar-footer clearfix" data-stick-bottom>
  <div class="bar-inner">
  
  <ul class="pager pull-left">
    
    <li class="prev">
      <a href="/2023/01/31/%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3/" title="C指针的理解"><i class="icon icon-angle-left" aria-hidden="true"></i><span>&nbsp;&nbsp;上一篇</span></a>
    </li>
    
    
    <li class="next">
      <a href="/2022/03/23/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/" title="常用Linux命令"><span>下一篇&nbsp;&nbsp;</span><i class="icon icon-angle-right" aria-hidden="true"></i></a>
    </li>
    
    
  </ul>
  
  
  
  <div class="bar-right">
    
    <div class="share-component" data-sites="weibo,qq,wechat,facebook,twitter" data-mobile-sites="weibo,qq,qzone"></div>
    
  </div>
  </div>
</nav>
  


</main>

  <footer class="footer" itemscope itemtype="http://schema.org/WPFooter">
	
	
    <ul class="social-links">
    	
        <li><a href="https://github.com/daidaini" target="_blank" title="Github" data-toggle=tooltip data-placement=top><i class="icon icon-github"></i></a></li>
        
    </ul>

    <div class="copyright">
    	
        <div class="publishby">
        	Theme by <a href="https://github.com/cofess" target="_blank"> cofess </a>base on <a href="https://github.com/cofess/hexo-theme-pure" target="_blank">pure</a>.
        </div>
    </div>
</footer>
  <script src="//cdn.jsdelivr.net/npm/jquery@1.12.4/dist/jquery.min.js"></script>
<script>
window.jQuery || document.write('<script src="js/jquery.min.js"><\/script>')
</script>

<script src="/js/plugin.min.js"></script>


<script src="/js/application.js"></script>


    <script>
(function (window) {
    var INSIGHT_CONFIG = {
        TRANSLATION: {
            POSTS: '文章',
            PAGES: '页面',
            CATEGORIES: '分类',
            TAGS: '标签',
            UNTITLED: '(未命名)',
        },
        ROOT_URL: '/',
        CONTENT_URL: '/content.json',
    };
    window.INSIGHT_CONFIG = INSIGHT_CONFIG;
})(window);
</script>

<script src="/js/insight.js"></script>






   




   






</body>
</html>