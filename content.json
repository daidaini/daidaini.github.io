{"meta":{"title":"个人博客","subtitle":"daidaini的学习空间","description":"程序员记录学习内容的地方","author":"yubo","url":"https://daidaini.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-07-30T05:40:44.656Z","updated":"2021-07-30T05:40:44.656Z","comments":false,"path":"categories/index.html","permalink":"https://daidaini.github.io/categories/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-01-30T03:31:09.618Z","updated":"2021-07-30T05:40:44.657Z","comments":false,"path":"repository/index.html","permalink":"https://daidaini.github.io/repository/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T05:40:44.657Z","updated":"2021-07-30T05:40:44.657Z","comments":false,"path":"tags/index.html","permalink":"https://daidaini.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"常用Linux命令","slug":"常用Linux命令","date":"2022-03-23T13:14:28.000Z","updated":"2023-01-30T06:28:32.078Z","comments":true,"path":"2022/03/23/常用Linux命令/","link":"","permalink":"https://daidaini.github.io/2022/03/23/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"文件操作相关 chmodchmod有两种操作方式,一种为普通授权法： 1234chmod +x a.txt #给a.txt可执行的权限chmod +r a.txt #给a.txt可读的权限 文件权限，’r’ 代表可读(4)，’w’代表可写(2)， ‘x’代表可执行(1) 上面括号内的数字 代表 “8421法”，即第二种操作方式。 12chmod 777 a.txt #表示给a.txt所有权限 关于文件的权限信息说明： -r-xr-xr-x 1 yubo yubo 342 May 27 22:06 hello.sh* 前面的 “-r-xr-xr-x” 即对应文件的权限信息。 其中，第一位是’-‘ 这个表示文件， 如果是’d’就表示文件夹； 后面分为三组，分别表示 “拥有者的权限”，“拥有者所在的组、组员的权限”，“其他用户的权限”； 每一组的权限，都是三位，分别代表 读写和执行的权限，所以，如果三个权限都有，就稳定为 “rwx”。 对上述文件，修改，使文件所有者有 所有权限： 123chmod 755 hello.sh$ll$-rwxr-xr-x 1 yubo yubo 342 May 27 22:06 hello.sh* [Linux]创建新用户及用户权限 - 知乎 (zhihu.com) sudosudo 命令 以系统管理者的身份执行，也就是说，经由sudo执行的命令就好像 是 root亲自执行。需要输入自己的账户密码。使用权限: 在 /etc/sudoers 中出现的使用者 12#以yao用户身份编辑 home目录下的index.html文件$ sudo -u yao vi ~www/index.html 编辑文件命令: vi 和 vim 操作： vi + 文件名 进入后，操作界面有三种模式：命令模式、插入模式和底行模式 三种模式相关定义： 命令模式 刚进入文件就是命令模式，通过方向键控制光标位置， 使用命令”dd”删除当前整行 使用命令”/字段”进行查找 按”i”在光标所在字符前开始插入 按”a”在光标所在字符后开始插入 按”o”在光标所在行的下面另起一新行插入 按”：”进入底行模式 插入模式 此时可以对文件内容进行编辑，左下角会显示 “– 插入 –”” 按”ESC”进入底行模式 底行模式 退出编辑 :q 强制退出 :q! 保存并退出 :wq 操作步骤示例 保存并退出编辑 “ESC” -&gt; 输入”:” -&gt; 输入”wq”,回车 取消操作：按”ESC” -&gt; 输入”:” -&gt; 输入”q!”,回车 补充 1234vim +10 filename.txt #打开文件并跳到第10行vim -R /etc/passwd #以只读模式打开文件 文件创建查看删除123456789101112131415#创建文件touch a.txt#移动文件mv [选项] 文件名 [目标文件名|目标路径]#复制文件cp [选项] 源文件 目标文件#复制文件夹cp -r dir1 dir2#删文件 -f 忽略警告信息 -i 删除前先询问rm [选项] 文件#删除文件夹 rm -r 目录名#重命名rename libfmt.a libfmt.a.bak libfmt.a diff显示两个文件的差异 1diff -c file1 file2 压缩/解压文件 tar[选项][文件] 1234#打包并压缩文件，压缩包后缀为 .tar.gztar -czvf *.tar.gz#解压并展开压缩包，压缩包后缀为 .tar.gztar -xzvf *.tar.gz 具体参数参考如下： 参数 作用 -c 创建压缩文件 -x 解开压缩文件 -t 查看压缩包内有哪些文件 -z 用Gzip压缩或者解压 -j 用bip2压缩或者解压 -v 显示压缩或者解压的过程 -f 目标文件名 -p 保留原始的权限和属性 -P 使用绝对路径来压缩 -C 指定解压到的目录 查找文件find12345678910111213141516find /bin -name &#x27;a*&#x27; #查找bin目录下所有以a开头的文件或者目录find . -name &#x27;*.c&#x27; #将当前目录及其子目录下，所有.c文件找出来find . -type f#将当前目录及其子目录下的所有一般文件列出find . -ctime -20#将当前目录及其子目录下 所有最近20天更新过的文件列出find . -type f -perm 664 -exec ls -l &#123;&#125; \\;#将当前目录及其子目录下， 所有权限为664的文件，列出#解释：这个命令可以分为两部分看，前半部分，到 -perm 664表示是查看文件的信息的权限；#后半部分，表示从执行ls -l 命令获取到的信息中进行筛选。 find工具笔记 whereis将和ls命令相关的文件都找出来 参数是某个命令（验证过 cmake ssh等） 1whereis ls whichwhich指令 会在环境变量 $PATH 设置的目录里查找符合条件的文件 1which is bash grep grep [选项] [文件] 12345#在文件中查找字符串（不区分大小写）grep -i &quot;the&quot; demo_file #在一个文件夹中递归查询包括指定字符串的文件grep -r &quot;remesh&quot; * 参数 作用 -b 将可执行文件(binary) 当作文本文件(txt)来搜索 -c 仅显示查找到的次数 -i 忽略大小写 -n 显示行号 -v 反向选择–仅列出没有“关键词”的行 下载文件wget12345#该命令用于从网上下载内容wget http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz#下载文件并以指定的文件名保存文件wget -O nagios.tar.gz http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz ftp12ftp IP/hostname //访问ftp服务器mls *.html - //显示远程主机上文件列表 scp通过scp命令在多台服务器中相互复制、传输文件(secure copy的缩写)scp 是linux系统下基于ssh登录进行安全的远程文件拷贝命令scp是加密的， rcp是不加密的， scp是rcp的加强版本 12scp /opt/data.txt 192.168.1.101:/opt/ #将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下 网络操作防火墙操作123456service iptables status //查看iptables服务的状态service iptables start //开启iptables服务service iptables stop //停止iptables服务service iptables restart //重启iptables服务chkconfig iptables off //关闭iptables服务的开机自启动chkconfig iptables on //开启iptables服务的开机自启动 查看网络信息123456789ifconfig#查看与IP的连接情况ping IP #查看当前系统端口netstat -an #查看指定端口netstat -an | grep 8080 #远程主机，需要输入用户名密码ssh IP lsof列出当前系统打开的文件描述符（list openfiles） 123456789101112#仅显示TCP连接（同理UDP）lsof -iTCP#显示与指定端口相关的网络信息lsof -i:3322#显示指定到指定主机的连接lsof -i@192.168.6.25#加端口lsof -i@192.168.6.25:23386#找出监听端口lsof -i -sTCP:LISTENlsof -i | grep -i LISTEN Linux 命令神器：lsof 修改IP修改网络配置文件，文件地址为 /etc/sysconfig/network-scripts/ifcfg-eth0 主要对应以下配置： 123456789TYPE=Ethernet //网络类型BOOTPROTO=static //静态IPDEVICE=ens00 //网卡名IPADDR=192.168.1.100 //设置的IPNETMASK=255.255.255.0 //子网掩码GATEWAY=192.168.1.1 //网关DNS1=192.168.1.1 //DNSDNS2=8.8.8.8 //备用DNSONBOOT=yes //系统启动时启动此设置 修改以后，使用命令重启网卡 1service network restart 配置映射修改文件 vi /etc/hosts在文件最后添加映射地址，示例如下： 123192.168.1.101 node1192.168.1.102 node2192.168.1.103 node3 配置好以后保存退出，输入命令：ping node1 ，可见实际 ping 的是 192.168.1.101。 tcpdump抓包分析工具使用tcpdump抓包 查看系统信息 1234#查看操作系统版本信息cat /proc/version#显示一些重要的系统信息，例如：内核名称、主机名、内核版本号、处理器类型之类信息uname -a 进程信息123456#查看所有正在运行的进程ps -ef#杀死pid进程kill pid#强制杀死该进程kill -9 pid service12345#service命令用于运行System V init脚本，这些脚本一般位于/etc/init.d 文件中#该命令可以直接运行脚本，而不需要加上路径service ssh status #查看服务状态service --status-all #查看所有服务状态service ssh restart #重启服务 free123#这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况free -g #以g为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节free -t #查看所有内存的汇总 top显示当前系统中占用资源最多的一些进程，shift+m 按照内存大小进行排序 df12#显示文件系统的磁盘使用情况df -h 环境变量12345678#查看当前环境变量echo $PATH#设置环境变量值export PATH=#添加一个路径export PATH=$PATH:newdir watch用于动态查看命令执行的结果比如，如果想要每隔一秒高亮显示 网络连接数的变化情况，则： 1watch -n 1 -d netstat -ant 每隔一秒高亮显示 http 连接数的变化情况 1watch -n 1 -d &#x27;pstree | grep http&#x27; vmstat常用系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析CPU上下文切换和中断的次数 其它 创建新用户root权限下，使用 useradd 命令进行 123useradd -m daidaini -c &quot;test creating a new user&quot;#指定密码passwd daidaini *** nohupno hang up 的缩写，不要挂起的意思，这个是常用的后台启动程序的方法。 在交互环境下，我们可以直接将一些信息输出到当前界面；那后台启动的程序，我们就会通常使用下边的命令，指定将信息输出到某个文件 1nohup command &gt; some.file 2&gt;&amp;1 &amp; 命令解释 1 表示标准输出 2 表示文件标准错误输出 2&gt;1&amp; 表示将两者合并，合并到的文件为some.file 常见命令","categories":[{"name":"Linux系统","slug":"Linux系统","permalink":"https://daidaini.github.io/categories/Linux%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://daidaini.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}]},{"title":"Linux多线程服务端编程","slug":"《Linux多线程服务端编程》阅读笔记","date":"2022-03-23T12:50:22.000Z","updated":"2022-03-23T13:12:08.493Z","comments":true,"path":"2022/03/23/《Linux多线程服务端编程》阅读笔记/","link":"","permalink":"https://daidaini.github.io/2022/03/23/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1 当一个对象能被多个线程同时看到时，那么这个对象的销毁时机就会变得模糊不清，可能出现多种竞态条件： 在即将析构一个对象时，从何而知此刻是否有其他线程正在执行该对象的成员函数 如何保证在执行成员函数期间，对象不会在另一个线程被析构 在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？ 解决这些race condtion是C++多线程编程面临的基本问题。可以使用shared_ptr来一劳永逸地解决这些问题。 2 对象构造要做到线程安全，唯一的要求是构造期间不能泄漏this指针。 基于此，二段式构造–即构造函数 + initialize() – 有时会是好办法。这种方式虽然不符合C++教条，但是多线程下别无选择。 3 mutex不能安全地保护析构，因为一旦执行析构，mutex对象也会被销毁。这样，在多线程的情况下，如果其他线程正在使用mutex用到一半，就会有问题。 4 空悬指针： 两个指针p1，p2，指向堆里的同一个对象Object，并且p1和p2位于不同的线程中（线程A和线程B）。假设线程A通过p1指针将对象销毁了，那么p2就成了悬空指针。这是一种典型的C/C++内存错误。 要想安全地销毁对象，最好在别人(即别的线程)都看不到的情况下，偷偷地做。这个也正是垃圾回收(gc)的原理，所有人用不到的一定是垃圾。 （悬空指针，是指指向的内容已经被释放的指针） 5 C++里可能出现的内存问题大致有如下几个方面： 缓冲区溢出 (buffer overrun) 空悬指针 / 野指针 重复释放 (double delete) 内存泄漏 (memory leak) 不配对的 new[] / delete 内存碎片 (memory fragment) 而正确地使用智能指针可以很轻易地解决前5种问题 6 shared_ptr的拷贝开销要比原始指针的拷贝开销要高（因为拷贝的时候需要修改引用计数，而修改引用计数需要加锁操作）。所以，我们在将shared_ptr作为函数参数传递的时候，尽量使用常引用的形式，这样减少拷贝次数，来减少性能损失。 7 让this指针，能变身为shared_ptr的方法，是让类继承 enable_shared_from_this。 8 弱回调：如果对象还活着，就调用它的成员函数，否则忽略之。 9 read-copy-update 10 不推荐使用信用量(Semaphore)，原因： 条件变量配合互斥量可以完全替代其功能，而且更不易出错 semaphore has no notion of ownership 信号量有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存放了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。 如果要控制并发度，可以考虑用muduo::ThreadPool 11 使用 pthread_once 来实现 Singleton 12 在”non-blocing IO + IO multiplexing” 这种模型（即Reactor模式）中，程序的基本结构是一个事件循环(event loop)， 以事件驱动(event-driven) 和事件回调的方式实现业务逻辑。 Reactor摸型的优点： 编程不难，效率也不错。不仅可以用于读写socket，连接的建立，甚至DNS解析都可以用非阻塞的方式进行，以提高并发度和吞吐量，对于IO密集的应用是一个不错的选择。 缺点： 它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护。 13 one loop per thread libev的作者说： One loop per thread is usually a good model. Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start. 这种方式的好处，在于： 线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁 可以很方便地在线程之间调配负载 IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发 Eventloop代表了线程的主循环，需要让哪个线程干活，就把timer或IOchannel(如TCP连接)注册到哪个线程的loop里即可。 对实时性有要求的额connection 可以单独用一个线程； 数据量大的connection可以独占一个线程，并把数据处理任务分摊到另几个计算线程中（用线程池）； 其他次要的辅助性connection可以共享一个线程。 对于具有一定规模的服务端程序，一般就会采用 non-blockong + IO multiplexing， 每个connection/acceptor 都会注册到某个eventloop上，程序里有多个event loop,每个线程至多有一个event loop。 多线程程序对event loop 提出了更高的要求，那就是“线程安全”。要允许一个线程往别的线程的loop里塞数据，这个loop必须得是线程安全的。 14 进程间通信首选Sockets(主要是指TCP)，其最大的好处在于：可以跨主机，具有伸缩性。其他优势： 在编程上，TCP sockets和pipe都是操作文件描述符，用来收发字节流，都可以 read/write/fcntl/poll等。不同的是，TCP是双向的；Linux的pipe是单向的，使用没有TCP方便 TCP的port是由一个进程独占的，而且操作系会自动回收(listening port 和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会自动关闭所有文件描述符)。这说明，即使程序意外退出，也不会给系统留下垃圾，程序重启之后就可以比较容易地恢复，而不需要重启操作系统。还有一个好处，既然port是独占的，就可以防止程序重复启动。 两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接，另一个进程就会立刻感知到，可以快速failover（故障转移）。 与其他IPC相比，TCP的一个天生的好处是“可记录、可重现”。tcpdump和Wireshark 是解决两个进程间协议和状态争端的好帮手，也是性能(吞吐量、延迟等)分析的利器。我们可以借此编写分布式程序的自动化回归测试。还可以用tcpcopy之类的工具进行压力测试。 TCP还能跨语言，服务端和客户端之间可以不必使用同一种语言 使用TCP这种字节流方式通信，会有 marshal/unmarshal的开销，这就要求我们选用合适的消息格式，准确的说是 wire format(字节序列？)，推荐用 Google Protocol Buffers 15 使用TCP长连接的好处有两点： 容易定位分布式系统中的服务之间的依赖关系。只要在机器上运行 netstat -tpna | grep :port 就能立刻列出用到某服务的客户端地址，然后在客户端的机器上用 netstat 或者 lsof 命令找出是哪个进程发起的连接。 通过接收和发送队列的长度也比较容易定位网络或者程序故障。 16 本书对 “服务器开发” 的定义，用一句话形容： 跑在多核机器上的Linux用户态的没有用户界面的长期运行的 网络应用程序，通常是分布式系统的组成部件。 17 多线程的适用场景时：提高响应速度，让IO和“计算”相互重叠，降低latency(延迟)。虽然多线程不能提高绝对性能，但是能提高平均响应性能。 一个程序要做成多线程的，大致要满足： 有多个CPU可用。单核机器上多线程没有性能优势(但或许能简化并发业务逻辑的实现) 线程间有共享数据，即内存中的全局状态。 共享的数据是可以修改的，而不是静态常量表。 提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件。防止优先级反转。 latency 和 throuthput 同样重要，不是逻辑简单的 IO密集或是 CPU密集。换言之，程序是有相当的计算量的 能scale up(有规模的增长)。 一个好的多线程程序应该能享受增加CPU数目带来的好处，一旦CPU从8核升级到16核，程序能体现出这种升级带来的性能提升 具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点之后会极速下降。线程数目一般不随负载变化。 多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是所有逻辑塞到一个event loop中，导致不同类别的事件之间相互影响 18 多线程服务程序中的线程大致可以分为三类： IO线程，这类线程的主循环是IO multiplexing，阻塞地等在 select/poll/epoll_wait 等系统调用上。这类线程也处理定时事件。当然，它的功能不光光是IO，有些简单的计算也可以放入其中，比如消息的编码或者解码等。 计算线程，这类线程的主循环是 blocingqueue， 阻塞地等在 conditionvariable上。这类线程一般位于 thread pool中。这种线程一般不涉及IO，一般要避免任何阻塞操作 第三方库所用的线程，比如 logging ，又比如database connection等 19 Linux 能同时启动多少个线程？ 对于32-bit Linux，一个进程的地址空间是4GB，其中用户态能访问的为3GB左右，而一个线程的默认栈大小是10 MB，简单计算，一个进程大约可以同时启动300个线程。 对于64-bit系统，线程数目可大大增加 20 尽管C++03标准没有明说标准库的线程安全性，但 我们可以遵循一个基本原则：凡是非共享的对象都是彼此独立的，如果一个对象从始至终只被一个线程使用，那么它就是安全的。 另外一个事实标准是：共享的对象的read-only操作是安全的，前提是不能有并发的写操作。","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"https://daidaini.github.io/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"初始化列表","slug":"初始化列表","date":"2022-03-23T12:50:22.000Z","updated":"2023-01-30T03:01:06.806Z","comments":true,"path":"2022/03/23/初始化列表/","link":"","permalink":"https://daidaini.github.io/2022/03/23/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/","excerpt":"","text":"初始化列表的概念及使用C++98中，标准允许使用花括号”{}”对数组元素进行统一的集合初始值设定。比如： 12int arr[5] = &#123;0&#125;;int arr[] = &#123;1,2,3,4&#125;; C++11中，这种初始化的方法，被扩展到了集合（列表）中。 总结初始化方法如下：1） 等号加上赋值表达式，如 int a = 3+4；2） 等号 加上花括号的 初始化列表， 如 int a = {3+4};3） 圆括号式的表达式列表（expression list）, 如 int a = (3+4);4） 花括号式的初始化列表 ， 如 int a{3+4} 其中，第3、4中方式也可用于获取堆内存 new操作符中，如下： 12int * i = new int(5);double *d = new double(1.5f); 标准模板库中容器对初始化列表的支持源自这个头文件中initialize_list的类模板的支持。只需要包含这个头文件，并且声明一个以initialize_list模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。 利用初始化列表，重载operator[]，operator= 以及使用辅助的数组。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt;using namespace std;class Mydata&#123;public: Mydata&amp; operator[](initializer_list&lt;int&gt; l)&#123; for(auto i=l.begin();i!=l.end();++i) idx.push_back(*i); return *this; &#125; Mydata&amp; operator=(int v)&#123; if(idx.empty()!=true) &#123; for(auto i = idx.begin();i!=idx.end();++i) &#123; d.resize((*i&gt;d.size())?*i:d.size()); d[*i-1] = v; &#125; idx.clear(); &#125; return *this; &#125; void print()&#123; for(auto i=d.begin();i!=d.end();++i) cout&lt;&lt;*i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;private: vector&lt;int&gt; idx; //辅助数组，用于记录index vector&lt;int&gt; d; &#125;;int main()&#123; Mydata d; d[&#123;2,3,5&#125;] = 7; //将第2，3，5位设为7 d[&#123;1,4,5,8&#125;] = 4; //第1，4，5，8位设为4 d.print(); //4 7 7 4 7 0 0 4&#125; 此外，初始化列表还可以用于函数返回的情况，但是返回一个初始化列表，通常会导致构造一个临时变量 123vector&lt;int&gt;Func()&#123; return &#123;1,3&#125;;&#125; 防止类型收窄使用列表初始化还有一个最大优势是 可以防止类型收窄。 类型收窄 一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。 可能导致 类型收窄的典型情况如下： 以浮点数隐式地转换为整型 比如： int a = 1.2 从高精度的浮点数转化为低精度的浮点数，比如： 从long double 隐式地转为 double。或者从double 转为 float。 这种精度降低，都可以视为类型收窄 从整型转为浮点数。如果整型数大到无法使用浮点数精确表达，也可以视为类型收窄 从整型，转为较低长度地整型。 比如：unsigned char = 1024; 1024是不能被8位地unsigned char 容纳的 使用初始化列表，是不能容许类型收窄的情况出现的。会编译通不过。 使用自定义初始化列表示例： 12345678910111213141516171819class Warriors&#123;public: Warriors(const initializer_list&lt;string&gt;&amp; members) &#123; for (auto&amp; data : members) &#123; players.emplace_back(data); &#125; &#125; vector&lt;string&gt; players; void print() &#123; for (auto itm : players) std::cout &lt;&lt; itm &lt;&lt; endl; &#125;&#125;;","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++特性","slug":"C-特性","permalink":"https://daidaini.github.io/tags/C-%E7%89%B9%E6%80%A7/"}]},{"title":"std::function的实验","slug":"函数模板function的实验","date":"2021-07-30T04:25:28.000Z","updated":"2023-01-30T03:00:07.407Z","comments":true,"path":"2021/07/30/函数模板function的实验/","link":"","permalink":"https://daidaini.github.io/2021/07/30/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BFfunction%E7%9A%84%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"std::function使用的几种形式 1234567891011121314151617181920212223242526272829303132inline namespace function_use&#123; int FuncB(int x, int y) &#123; return x + y; &#125; struct FuncC &#123; int operator()(int x, int y) &#123; return x + y; &#125; &#125;; void test_use_function() &#123; using funcType = std::function&lt;int(int, int)&gt;; funcType a = [](int x, int y) &#123; return x + y; &#125;; funcType b = FuncB; funcType c = FuncC(); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c(30, 4) &lt;&lt; endl; &#125;&#125; 结果如下 a = 7b = 70c = 34 增加变化，加一个类如下 1234567891011121314151617181920212223class FuncContainer&#123;public: void Push(funcType&amp;&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp;&amp; func)\\n&quot;; m_contianer.emplace_back(std::forward&lt;funcType&gt;(func)); &#125; void Push(funcType&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp; func)\\n&quot;; m_contianer.emplace_back(func); &#125; funcType&amp; Take(int index) &#123; cout &lt;&lt; &quot;using funcType&amp; Take(int index)\\n&quot;; return m_contianer[index]; &#125;private: vector&lt;funcType&gt; m_contianer;&#125;; 测试方法如下 123456789101112131415void test_use_function()&#123; FuncContainer container; container.Push([](int x, int y) &#123; return x + y; &#125;); container.Push(FuncB); container.Push(FuncC()); auto afunc = container.Take(0); auto bfunc = container.Take(1); auto cfunc = container.Take(2); cout &lt;&lt; &quot;a = &quot; &lt;&lt; afunc(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; bfunc(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; cfunc(30, 4) &lt;&lt; endl;&#125; 测试结果 using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using funcType&amp; Take(int index)using funcType&amp; Take(int index)using funcType&amp; Take(int index)a = 7b = 70c = 34 实验结论 std::function 作为通用的多态函数封装器， std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针 std::function 配合using （或者typedef），可以用来作为容器的元素进行存储 std::function 作为函数参数传递时，都是作为右值引用来进行传递的 std::function 重载的 operator= 返回的是引用类型，所以，需要注意其存储元素的生命周期 参考: std::function - C++中文 - API参考文档 (apiref.com) http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++标准库","slug":"C-标准库","permalink":"https://daidaini.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"}]},{"title":"C++标准线程库的使用","slug":"C-11线程","date":"2021-07-30T01:59:29.000Z","updated":"2023-01-30T03:11:37.007Z","comments":true,"path":"2021/07/30/C-11线程/","link":"","permalink":"https://daidaini.github.io/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"引子c++11后新增了线程库，最主要最熟知的应该就是 std::thread，以及配合以线程同步用的std::mutex和std::conditon_variable。 对于多核环境的高性能并发处理，后端开发最需要熟知的就是线程池。线程池本质上就是提前建立好多个线程，在需要使用的时候唤醒一个来处理，不需要的时候让其睡眠不占用资源。 以下先介绍标准线程库的一些使用方法，然后再依次实现下线程池。 使用std::thread库基本使用方式1234void ThreadFunc()&#123; //do something&#125;std::thread t(ThreadFunc); 如果是带参数的线程函数，就可以： 123456void ThreadFunc(int count)&#123; //do something&#125;std::thread t(ThreadFunc, 5);//或者 使用&lt;functional&gt;中提供的 std::bind方法，将参数绑定到对应的线程函数上std::thread t(std::bind(ThreadFunc, 5)); 关于线程的结束线程启动后，一般需要等到线程函数运行完，线程才能结束 标准库对于线程的结束也有两种方式： 1） 在主线程中调用join方法，主线程就会阻塞等待到线程函数运行完，然后结束 12if(t.joinable()) t.join() 2）调用detach方法，将线程从主线程分离。这种形式，主线程不会被阻塞，也不会知道分离出去的线程什么时候结束。 如果确定主线程肯定比线程函数晚结束，或者线程和主线程的存活时间是一致的，则可以直接在启动线程后，直接detach。 123t.detach();//简便的写法，声明和detach一起调用std::thread(ThreadFunc).detach(); std::thread启动线程的其他方式std::thread启动线程，也可以使用lambda表达式，参考如下： 1234567std::thread([]()&#123; for (int i = 0; i &lt; 20; ++i) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; static_cast&lt;char&gt;(&#x27;A&#x27; + i) &lt;&lt; endl; this_thread::sleep_for(10ms); &#125;&#125; ); 对于将参数为引用的函数来作为线程函数，也有如下两种操作可参考： 1） 使用lambda表达式，如下： 123456789101112131415unordered_map&lt;int, string&gt; myMapSrc&#123; &#123;1, &quot;first&quot; &#125;, &#123;2, &quot;second&quot;&#125;, &#123;3, &quot;third&quot;&#125;, &#123;4, &quot;four&quot;&#125;, &#123;5, &quot;five&quot;&#125; &#125;;//捕获列表使用 &amp; 就可以std::thread([&amp;myMapSrc]()&#123; for (const auto&amp; item : myMapSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125; ).detach(); 2） 使用std::bind，如下 12345678void ThreadFunc(unordered_map&lt;int, string&gt;&amp; refRec)&#123; for (const auto&amp; item : refSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125;std::thread(std::bind(ThreadFunc, std::ref(myMapSrc))); 由于std::bind总是使用值拷贝的形式传参，哪怕函数声明为引用，std::bind传递的时候也是值传递。所以，标准库提供了std::ref来给std::bind传引用。 std::async标准库，在std::thread的基础上，封装了一些方法，有std::promise，std::pacakged_task，以及std::async。 这其中，std::promise以及std::pacakged_task的使用，一般还是要配合std::thread以及std::future来。 这边，比较推荐使用std::async来启动一个线程来执行一个异步任务，简单的示例代码如下： 123std::async(launch::async, ThreadFunc);//带参数，则std::async(launch::async, ThreadFunc, param1, param2...); std::async 方法有返回值，类型是std::future 12345678910string ThreadFuncStr(int data)&#123; this_thread::sleep_for(1s); cout &lt;&lt; &quot;This is ThreadFuncStr\\n&quot;; return to_string(data);&#125;std::future&lt;string&gt; result = std::async(launch::async, ThreadFuncStr, 100);//do some other thing string str = result.get();cout &lt;&lt; str &lt;&lt;endl; 说明： std::async， 如果第一个参数是launch::async，那就是立即启动线程任务，但是线程启动后，不会阻塞当前线程。 只有在后续调用reuslt.get()的时候，会阻塞，直到线程函数返回需要的结果。 使用建议： 推荐std::async，是因为它将thread的概念隐藏到了底层，方法本身就成为了，我就是异步去执行一个任务。 所以，如果我们一旦碰到需要读写文件或者网络请求这种涉及IO，耗时不确定可能会阻塞当前运行线程的时候，都可以调用async，来启动一个异步任务完成这部分的业务处理。 另外： 如果想使用std::thread的形式，也需要获取线程函数执行后的返回值，可以使用packaged_task，简单举例： 1234567int main()&#123; std::packaged_task&lt;string(int)&gt; task(ThreadFuncStr); std::future&lt;string&gt; async_result = task.get_future(); std::thread(std::move(task), 100).detach(); cout &lt;&lt; async_result.get() &lt;&lt; endl; return 0;&#125; 感觉用起来，不如std::async方便，感兴趣的可以自行研究(报考std::promise 也是，它们都有各自的应用场景)。 线程池有执行一个异步任务来获取结果的需求，肯定也有不定时执行多个异步任务的需求。 最典型的就是，服务端处理多个不同用户的业务逻辑的场景： 1）每个用户的业务处理，一般都需要在自己独立的线程中运行； 2）线程处理完一个用户的业务逻辑，还可以处理另一个用户的业务逻辑。 这种情况，就比较适合用线程池了。 下边就是用C++11标准库实现的线程池的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class FixedThreadPool&#123;public: using FuncTaskType = std::function&lt;void()&gt;; FixedThreadPool(size_t threadCount) : m_ResData(make_shared&lt;ResInfo&gt;()) &#123; for (size_t i = 0; i &lt; threadCount; ++i) &#123; std::thread(std::bind(&amp;FixedThreadPool::ThreadFunc, this)).detach(); &#125; &#125; ~FixedThreadPool() &#123; if (m_ResData != nullptr) &#123; std::lock_guard&lt;std::mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;IsShutdown = true; &#125; m_ResData-&gt;Cv.notify_all(); &#125; void Execute(FuncTaskType&amp;&amp; task) &#123; lock_guard&lt;mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;Tasks.emplace(std::forward&lt;FuncTaskType&gt;(task)); m_ResData-&gt;Cv.notify_one(); &#125;private: void ThreadFunc() &#123; unique_lock&lt;mutex&gt; lk(m_ResData-&gt;Mtx); do &#123; if (!m_ResData-&gt;Tasks.empty()) &#123; auto currentTask = std::move(m_ResData-&gt;Tasks.front()); m_ResData-&gt;Tasks.pop(); lk.unlock(); currentTask(); lk.lock(); &#125; else if (m_ResData-&gt;IsShutdown) &#123; break; &#125; else &#123; m_ResData-&gt;Cv.wait(lk); &#125; &#125; while (true); &#125; struct ResInfo &#123; mutex Mtx; condition_variable Cv; bool IsShutdown = false; //线程函数任务队列 queue&lt;FuncTaskType&gt; Tasks; &#125;; std::shared_ptr&lt;ResInfo&gt; m_ResData;&#125;; 简单解释： ResInfo 是需要的一些信息，包含线程同步用互斥量和条件变量，线程池的开关，以及存储线程任务的队列 ResInfo 使用 shared_ptr 是因为 每个线程都会进行一份拷贝 存储队列，使用queue，满足先进先出 线程任务，统一使用 函数模板 std::function&lt;void()&gt; ，这样，后续再配合std::bind，就可以执行所有带参数和不带参数的线程函数 构造的时候，直接启动对应数量的线程，每个线程的运行都封装在ThreadFunc ThreadFunc 使用unique_lock 一是需要配合条件变量进行wait， 二是，在将线程任务从队列中取出来之后，就不需要再锁了，可以unlock。 对于线程池内部的mutex，它用来保护的数据，其实就是线程任务队列，所以将线程任务从队列中取出来之后，这个锁的任务就达成了。 执行完线程任务，再锁住，是该线程在循环，执行完上一个任务，就会去队列中取下一个任务。 Execute方法，顾名思义，就是用来执行任务的。右值引用作为参数进行传递时，会转换成左值，需配合完美转发std::forward使用 最后，析构函数，主要是确保开关置为true，启动的线程函数可以正常运行结束。 参考: C++11 (三) - std::function、std::bind、std::ref C++11 std::thread detach()与join()用法总结","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++标准库","slug":"C-标准库","permalink":"https://daidaini.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"}]}],"categories":[{"name":"Linux系统","slug":"Linux系统","permalink":"https://daidaini.github.io/categories/Linux%E7%B3%BB%E7%BB%9F/"},{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"操作系统","slug":"操作系统","permalink":"https://daidaini.github.io/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"C++学习","slug":"C-学习","permalink":"https://daidaini.github.io/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"C++特性","slug":"C-特性","permalink":"https://daidaini.github.io/tags/C-%E7%89%B9%E6%80%A7/"},{"name":"C++标准库","slug":"C-标准库","permalink":"https://daidaini.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"}]}