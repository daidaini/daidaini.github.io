{"meta":{"title":"个人博客","subtitle":"daidaini的学习空间","description":"C++编程学习","author":"俞波","url":"http://example.com","root":"/"},"pages":[{"title":"Repositories","date":"2021-07-30T05:40:44.657Z","updated":"2021-07-30T05:40:44.657Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"","slug":"《Linux多线程服务端编程》笔记","date":"2022-03-19T05:35:24.857Z","updated":"2022-03-19T05:35:25.004Z","comments":true,"path":"2022/03/19/《Linux多线程服务端编程》笔记/","link":"","permalink":"http://example.com/2022/03/19/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/","excerpt":"","text":"《Linux多线程服务端编程》 1 当一个对象能被多个线程同时看到时，那么这个对象的销毁时机就会变得模糊不清，可能出现多种竞态条件： 在即将析构一个对象时，从何而知此刻是否有其他线程正在执行该对象的成员函数 如何保证在执行成员函数期间，对象不会在另一个线程被析构 在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？ 解决这些race condtion是C++多线程编程面临的基本问题。可以使用shared_ptr来一劳永逸地解决这些问题。 2 对象构造要做到线程安全，唯一的要求是构造期间不能泄漏this指针。 基于此，二段式构造–即构造函数 + initialize() – 有时会是好办法。这种方式虽然不符合C++教条，但是多线程下别无选择。 3 mutex不能安全地保护析构，因为一旦执行析构，mutex对象也会被销毁。这样，在多线程的情况下，如果其他线程正在使用mutex用到一半，就会有问题。 4 空悬指针： 两个指针p1，p2，指向堆里的同一个对象Object，并且p1和p2位于不同的线程中（线程A和线程B）。假设线程A通过p1指针将对象销毁了，那么p2就成了悬空指针。这是一种典型的C/C++内存错误。 要想安全地销毁对象，最好在别人(即别的线程)都看不到的情况下，偷偷地做。这个也正是垃圾回收(gc)的原理，所有人用不到的一定是垃圾。 （悬空指针，是指指向的内容已经被释放的指针） 5 C++里可能出现的内存问题大致有如下几个方面： 缓冲区溢出 (buffer overrun) 空悬指针 / 野指针 重复释放 (double delete) 内存泄漏 (memory leak) 不配对的 new[] / delete 内存碎片 (memory fragment) 而正确地使用智能指针可以很轻易地解决前5种问题 6 shared_ptr的拷贝开销要比原始指针的拷贝开销要高（因为拷贝的时候需要修改引用计数，而修改引用计数需要加锁操作）。所以，我们在将shared_ptr作为函数参数传递的时候，尽量使用常引用的形式，这样减少拷贝次数，来减少性能损失。 7 让this指针，能变身为shared_ptr的方法，是让类继承 enable_shared_from_this。 8 弱回调：如果对象还活着，就调用它的成员函数，否则忽略之。 9 read-copy-update 10 不推荐使用信用量(Semaphore)，原因： 条件变量配合互斥量可以完全替代其功能，而且更不易出错 semaphore has no notion of ownership 信号量有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存放了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。 如果要控制并发度，可以考虑用muduo::ThreadPool 11 使用 pthread_once 来实现 Singleton 12 在”non-blocing IO + IO multiplexing” 这种模型（即Reactor模式）中，程序的基本结构是一个事件循环(event loop)， 以事件驱动(event-driven) 和事件回调的方式实现业务逻辑。 Reactor摸型的优点： 编程不难，效率也不错。不仅可以用于读写socket，连接的建立，甚至DNS解析都可以用非阻塞的方式进行，以提高并发度和吞吐量，对于IO密集的应用是一个不错的选择。 缺点： 它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护。 13 one loop per thread libev的作者说： One loop per thread is usually a good model. Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start. 这种方式的好处，在于： 线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁 可以很方便地在线程之间调配负载 IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发 Eventloop代表了线程的主循环，需要让哪个线程干活，就把timer或IOchannel(如TCP连接)注册到哪个线程的loop里即可。 对实时性有要求的额connection 可以单独用一个线程； 数据量大的connection可以独占一个线程，并把数据处理任务分摊到另几个计算线程中（用线程池）； 其他次要的辅助性connection可以共享一个线程。 对于具有一定规模的服务端程序，一般就会采用 non-blockong + IO multiplexing， 每个connection/acceptor 都会注册到某个eventloop上，程序里有多个event loop,每个线程至多有一个event loop。 多线程程序对event loop 提出了更高的要求，那就是“线程安全”。要允许一个线程往别的线程的loop里塞数据，这个loop必须得是线程安全的。 14 进程间通信首选Sockets(主要是指TCP)，其最大的好处在于：可以跨主机，具有伸缩性。其他优势： 在编程上，TCP sockets和pipe都是操作文件描述符，用来收发字节流，都可以 read/write/fcntl/poll等。不同的是，TCP是双向的；Linux的pipe是单向的，使用没有TCP方便 TCP的port是由一个进程独占的，而且操作系会自动回收(listening port 和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会自动关闭所有文件描述符)。这说明，即使程序意外退出，也不会给系统留下垃圾，程序重启之后就可以比较容易地恢复，而不需要重启操作系统。还有一个好处，既然port是独占的，就可以防止程序重复启动。 两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接，另一个进程就会立刻感知到，可以快速failover（故障转移）。 与其他IPC相比，TCP的一个天生的好处是“可记录、可重现”。tcpdump和Wireshark 是解决两个进程间协议和状态争端的好帮手，也是性能(吞吐量、延迟等)分析的利器。我们可以借此编写分布式程序的自动化回归测试。还可以用tcpcopy之类的工具进行压力测试。 TCP还能跨语言，服务端和客户端之间可以不必使用同一种语言 使用TCP这种字节流方式通信，会有 marshal/unmarshal的开销，这就要求我们选用合适的消息格式，准确的说是 wire format(字节序列？)，推荐用 Google Protocol Buffers 15 使用TCP长连接的好处有两点： 容易定位分布式系统中的服务之间的依赖关系。只要在机器上运行 netstat -tpna | grep :port 就能立刻列出用到某服务的客户端地址，然后在客户端的机器上用 netstat 或者 lsof 命令找出是哪个进程发起的连接。 通过接收和发送队列的长度也比较容易定位网络或者程序故障。 16 本书对 “服务器开发” 的定义，用一句话形容： 跑在多核机器上的Linux用户态的没有用户界面的长期运行的 网络应用程序，通常是分布式系统的组成部件。 17 多线程的适用场景时：提高响应速度，让IO和“计算”相互重叠，降低latency(延迟)。虽然多线程不能提高绝对性能，但是能提高平均响应性能。 一个程序要做成多线程的，大致要满足： 有多个CPU可用。单核机器上多线程没有性能优势(但或许能简化并发业务逻辑的实现) 线程间有共享数据，即内存中的全局状态。 共享的数据是可以修改的，而不是静态常量表。 提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件。防止优先级反转。 latency 和 throuthput 同样重要，不是逻辑简单的 IO密集或是 CPU密集。换言之，程序是有相当的计算量的 能scale up(有规模的增长)。 一个好的多线程程序应该能享受增加CPU数目带来的好处，一旦CPU从8核升级到16核，程序能体现出这种升级带来的性能提升 具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点之后会极速下降。线程数目一般不随负载变化。 多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是所有逻辑塞到一个event loop中，导致不同类别的事件之间相互影响 18 多线程服务程序中的线程大致可以分为三类： IO线程，这类线程的主循环是IO multiplexing，阻塞地等在 select/poll/epoll_wait 等系统调用上。这类线程也处理定时事件。当然，它的功能不光光是IO，有些简单的计算也可以放入其中，比如消息的编码或者解码等。 计算线程，这类线程的主循环是 blocingqueue， 阻塞地等在 conditionvariable上。这类线程一般位于 thread pool中。这种线程一般不涉及IO，一般要避免任何阻塞操作 第三方库所用的线程，比如 logging ，又比如database connection等 19 Linux 能同时启动多少个线程？ 对于32-bit Linux，一个进程的地址空间是4GB，其中用户态能访问的为3GB左右，而一个线程的默认栈大小是10 MB，简单计算，一个进程大约可以同时启动300个线程。 对于64-bit系统，线程数目可大大增加 20 尽管C++03标准没有明说标准库的线程安全性，但 我们可以遵循一个基本原则：凡是非共享的对象都是彼此独立的，如果一个对象从始至终只被一个线程使用，那么它就是安全的。 另外一个事实标准是：共享的对象的read-only操作是安全的，前提是不能有并发的写操作。","categories":[],"tags":[]},{"title":"进程与线程","slug":"进程与线程","date":"2021-09-10T05:47:31.000Z","updated":"2021-09-10T05:50:15.416Z","comments":true,"path":"2021/09/10/进程与线程/","link":"","permalink":"http://example.com/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程与线程的区别 当我们把代码编译链接生成后的可执行文件，装载到内存中进行运行，这个运行中的实例就是进程。 同一个可执行文件，可以有多个进程实例。而且，每个进程之间的内存资源都是相互独立、互不影响的。 换句话解释就是，进程是操作系统进行资源调度和内存分配的基本单位。 这些进程独享的资源，包括有代码、打开的文件、堆、栈、存放全局变量的数据段 以及一些内核内部使用的数据，比如运行状态等。 现代的操作系统都是会并发处理多任务的，所以必然会同时处理多个进程，那就必然需要进行进程的切换。而切换进程，意味着，需要将进程独占的那些资源都进行切换。 那由于进程管理的资源较多，相对切换的成本开销就较大了。这也是引入线程的概念的原因，线程是进程的一个子任务，是用来作为操作系统进行任务调度的最小单位。 首先线程是相对进程更轻量级的存在， 单个进程的线程间共享的资源包括： 代码段 全局数据段和静态数据段 栈区 理论上，栈区是属于线程是有的。 但是实际上，不同线程的栈区并没有严格的隔离机制来进行保护。 因此，如果一个线程拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说， 这些线程可以任意膝盖本属于另一个线程中的变量。 堆区 打开的文件描述符 命令行参数 信号处理函数 进程ID、进程组ID 线程独占的资源有：（即线程上下文） 线程的栈区 栈指针?(用来指向栈顶吗？) 程序计数器（一种寄存器） 函数运行使用的寄存器（保存部分局部变量之类） TLS(Thread Local Storage) 线程间到底共享了哪些进程资源 - 知乎 (zhihu.com) 保存进程的信息的地方 称为PCB，进程控制块。 保存线程的信息的地方，就是TCB，线程控制块。 PCB存储的信息包括各种资源信息：内存地址空间信息、所有打开的文件、所有的I/O设备信息， 此外，还有进程描述符（即进程的标识，进程id），进程的运行状态，对应的用户描述符，各种寄存器的信息，以及进程的优先级（操作系统用来进行调度的算法需要）等信息。 TCB就相对少一点，除了线程描述符，也会记录对应的进程描述符，还有栈、寄存器等相关信息。","categories":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/categories/C-11/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"std-function","slug":"std-function","date":"2021-07-30T04:25:28.000Z","updated":"2021-08-02T02:31:37.177Z","comments":true,"path":"2021/07/30/std-function/","link":"","permalink":"http://example.com/2021/07/30/std-function/","excerpt":"","text":"std::function 测试实验如下： 1234567891011121314151617181920212223242526272829303132inline namespace test&#123; int FuncB(int x, int y) &#123; return x + y; &#125; struct FuncC &#123; int operator()(int x, int y) &#123; return x + y; &#125; &#125;; void test_use_function() &#123; using funcType = std::function&lt;int(int, int)&gt;; funcType a = [](int x, int y) &#123; return x + y; &#125;; funcType b = FuncB; funcType c = FuncC(); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c(30, 4) &lt;&lt; endl; &#125;&#125; 结果如下： a = 7b = 70c = 34 增加变化，加一个类如下 12345678910111213141516171819202122232425class FuncContainer &#123; public: void Push(funcType&amp;&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp;&amp; func)\\n&quot;; m_contianer.emplace_back(std::forward&lt;funcType&gt;(func)); &#125; void Push(funcType&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp; func)\\n&quot;; m_contianer.emplace_back(func); &#125; funcType&amp; Take(int index) &#123; cout &lt;&lt; &quot;using funcType&amp; Take(int index)\\n&quot;; return m_contianer[index]; &#125; private: vector&lt;funcType&gt; m_contianer; &#125;; 测试方法如下： 1234567891011121314151617void test_use_function() &#123; FuncContainer container; container.Push([](int x, int y) &#123; return x + y; &#125;); container.Push(FuncB); container.Push(FuncC()); auto afunc = container.Take(0); auto bfunc = container.Take(1); auto cfunc = container.Take(2); cout &lt;&lt; &quot;a = &quot; &lt;&lt; afunc(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; bfunc(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; cfunc(30, 4) &lt;&lt; endl; &#125; 测试结果： using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using funcType&amp; Take(int index)using funcType&amp; Take(int index)using funcType&amp; Take(int index)a = 7b = 70c = 34 实验结论： std::function 作为通用的多态函数封装器， std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针 std::function 配合using （或者typedef），可以用来作为容器的元素进行存储 std::function 作为函数参数传递时，都是作为右值引用来进行传递的 std::function 重载的 operator= 返回的是引用类型，所以，需要注意其存储元素的生命周期 参考： std::function - C++中文 - API参考文档 (apiref.com) http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E","categories":[{"name":"C++编程","slug":"C-编程","permalink":"http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/tags/C-11/"}]},{"title":"C++11线程库使用","slug":"C-11线程","date":"2021-07-30T01:59:29.000Z","updated":"2021-08-02T02:31:29.105Z","comments":true,"path":"2021/07/30/C-11线程/","link":"","permalink":"http://example.com/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"c++11线程概述关于线程池，之前交易网关这边虽然会管理多个线程，但一直没有用到线程池去管理。 前段时间，给国密的mauth服务器做一个校验账号密码的通讯组件的时候，使用了一个线程处理一个用户的校验的设计，所以尝试着去使用了线程池， 并且，他们的程序是运行在linux系统的，所以线程池也首次使用了c++11的方法去实现 c++11新增了线程库，最主要最熟知的应该就是 std::thread，以及配合以线程同步用的std::mutex和std::conditon_variable。 有了以上三个特性，我们可以很简便的实现一个跨线程的任务队列(BlockingQueue)，这个是实现线程池的基础。 所以，今天主要先分享下 c++11 线程库使用的一些方法，然后再分享下c++11的线程池实现。 std::thread使用thread库最常见的启动一个线程的方法： 1234void ThreadFunc()&#123; //do something&#125;std::thread t(ThreadFunc); 如果是带参数的线程函数，就可以： 123456void ThreadFunc(int count)&#123; //do something&#125;std::thread t(ThreadFunc, 5);//或者 使用&lt;functional&gt;中提供的 std::bind方法，将参数绑定到对应的线程函数上std::thread t(std::bind(ThreadFunc, 5)); 交易网关这边，基于std::thread实现了一个ThreadBase的类，来封装线程的启动和停止，可以参考。 关于线程的结束线程启动后，一般需要等到线程函数运行完，线程才能结束 标准库对于线程的结束也有两种方式： 1） 在主线程中调用join方法，主线程就会阻塞等待到线程函数运行完，然后结束 12if(t.joinable()) t.join() 2）调用detach方法，将线程从主线程分离。这种形式，主线程不会被阻塞，也不会知道分离出去的线程什么时候结束。 如果确定主线程肯定比线程函数晚结束，或者线程和主线程的存活时间是一致的，则可以直接在启动线程后，直接detach。 123t.detach();//简便的写法，声明和detach一起调用std::thread(ThreadFunc).detach(); thread启动线程的其他方式此外，std::thread启动线程，也可以使用lambda表达式，参考如下： 1234567std::thread([]()&#123; for (int i = 0; i &lt; 20; ++i) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; static_cast&lt;char&gt;(&#x27;A&#x27; + i) &lt;&lt; endl; this_thread::sleep_for(10ms); &#125;&#125; ); 对于将参数为引用的函数来作为线程函数，也有如下两种操作可参考： 1） 使用lambda表达式，如下： 123456789101112131415unordered_map&lt;int, string&gt; myMapSrc&#123; &#123;1, &quot;first&quot; &#125;, &#123;2, &quot;second&quot;&#125;, &#123;3, &quot;third&quot;&#125;, &#123;4, &quot;four&quot;&#125;, &#123;5, &quot;five&quot;&#125; &#125;;//捕获列表使用 &amp; 就可以std::thread([&amp;myMapSrc]()&#123; for (const auto&amp; item : myMapSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125; ).detach(); 2） 使用std::bind，如下 12345678void ThreadFunc(unordered_map&lt;int, string&gt;&amp; refRec)&#123; for (const auto&amp; item : refSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125;std::thread(std::bind(ThreadFunc, std::ref(myMapSrc))); 由于std::bind总是使用值拷贝的形式传参，哪怕函数声明为引用，std::bind传递的时候也是值传递。所以，标准库提供了std::ref来给std::bind传引用。 std::async标准库，在std::thread的基础上，封装了一些方法，有std::promise，std::pacakged_task，以及std::async。 这其中，std::promise以及std::pacakged_task的使用，一般还是要配合std::thread以及std::future来。 这边，比较推荐使用std::async来启动一个线程来执行一个异步任务，简单的示例代码如下： 123std::async(launch::async, ThreadFunc);//带参数，则std::async(launch::async, ThreadFunc, param1, param2...); std::async 方法有返回值，类型是std::future 12345678910string ThreadFuncStr(int data)&#123; this_thread::sleep_for(1s); cout &lt;&lt; &quot;This is ThreadFuncStr\\n&quot;; return to_string(data);&#125;std::future&lt;string&gt; result = std::async(launch::async, ThreadFuncStr, 100);//do some other thing string str = result.get();cout &lt;&lt; str &lt;&lt;endl; 说明： std::async， 如果第一个参数是launch::async，那就是立即启动线程任务，但是线程启动后，不会阻塞当前线程。 只有在后续调用reuslt.get()的时候，会阻塞，直到线程函数返回需要的结果。 使用建议： 推荐std::async，是因为它将thread的概念隐藏到了底层，方法本身就成为了，我就是异步去执行一个任务。 所以，如果我们一旦碰到需要读写文件或者网络请求这种涉及IO，耗时不确定可能会阻塞当前运行线程的时候，都可以调用async，来启动一个异步任务完成这部分的业务处理。 另外： 如果想使用std::thread的形式，也需要获取线程函数执行后的返回值，可以使用packaged_task，简单举例： 1234567int main()&#123; std::packaged_task&lt;string(int)&gt; task(ThreadFuncStr); std::future&lt;string&gt; async_result = task.get_future(); std::thread(std::move(task), 100).detach(); cout &lt;&lt; async_result.get() &lt;&lt; endl; return 0;&#125; 感觉用起来，不如std::async方便，感兴趣的可以自行研究(报考std::promise 也是，它们都有各自的应用场景)。 线程池有执行一个异步任务来获取结果的需求，肯定也有不定时执行多个异步任务的需求。 最典型的就是，服务端处理多个不同用户的业务逻辑的场景： 1）每个用户的业务处理，一般都需要在自己独立的线程中运行； 2）线程处理完一个用户的业务逻辑，还可以处理另一个用户的业务逻辑。 这种情况，就比较适合用线程池了。 下边就是用C++11标准库实现的线程池的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class FixedThreadPool&#123;public: using FuncTaskType = std::function&lt;void()&gt;; FixedThreadPool(size_t threadCount) : m_ResData(make_shared&lt;ResInfo&gt;()) &#123; for (size_t i = 0; i &lt; threadCount; ++i) &#123; std::thread(std::bind(&amp;FixedThreadPool::ThreadFunc, this)).detach(); &#125; &#125; ~FixedThreadPool() &#123; if (m_ResData != nullptr) &#123; std::lock_guard&lt;std::mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;IsShutdown = true; &#125; m_ResData-&gt;Cv.notify_all(); &#125; void Execute(FuncTaskType&amp;&amp; task) &#123; lock_guard&lt;mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;Tasks.emplace(std::forward&lt;FuncTaskType&gt;(task)); m_ResData-&gt;Cv.notify_one(); &#125;private: void ThreadFunc() &#123; unique_lock&lt;mutex&gt; lk(m_ResData-&gt;Mtx); do &#123; if (!m_ResData-&gt;Tasks.empty()) &#123; auto currentTask = std::move(m_ResData-&gt;Tasks.front()); m_ResData-&gt;Tasks.pop(); lk.unlock(); currentTask(); lk.lock(); &#125; else if (m_ResData-&gt;IsShutdown) &#123; break; &#125; else &#123; m_ResData-&gt;Cv.wait(lk); &#125; &#125; while (true); &#125; struct ResInfo &#123; mutex Mtx; condition_variable Cv; bool IsShutdown = false; //线程函数任务队列 queue&lt;FuncTaskType&gt; Tasks; &#125;; std::shared_ptr&lt;ResInfo&gt; m_ResData;&#125;; 简单解释： ResInfo 是需要的一些信息，包含线程同步用互斥量和条件变量，线程池的开关，以及存储线程任务的队列 ResInfo 使用 shared_ptr 是因为 每个线程都会进行一份拷贝 存储队列，使用queue，满足先进先出 线程任务，统一使用 函数模板 std::function&lt;void()&gt; ，这样，后续再配合std::bind，就可以执行所有带参数和不带参数的线程函数 构造的时候，直接启动对应数量的线程，每个线程的运行都封装在ThreadFunc ThreadFunc 使用unique_lock 一是需要配合条件变量进行wait， 二是，在将线程任务从队列中取出来之后，就不需要再锁了，可以unlock。 对于线程池内部的mutex，它用来保护的数据，其实就是线程任务队列，所以将线程任务从队列中取出来之后，这个锁的任务就达成了。 执行完线程任务，再锁住，是该线程在循环，执行完上一个任务，就会去队列中取下一个任务。 Execute方法，顾名思义，就是用来执行任务的。右值引用作为参数进行传递时，会转换成左值，需配合完美转发std::forward使用 最后，析构函数，主要是确保开关置为true，启动的线程函数可以正常运行结束。 参考: C++11 (三) - std::function、std::bind、std::ref C++11 std::thread detach()与join()用法总结 《Linux多线程服务端编程》","categories":[{"name":"C++编程","slug":"C-编程","permalink":"http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/tags/C-11/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-30T01:53:10.230Z","updated":"2021-07-30T01:53:10.230Z","comments":true,"path":"2021/07/30/hello-world/","link":"","permalink":"http://example.com/2021/07/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/categories/C-11/"},{"name":"C++编程","slug":"C-编程","permalink":"http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"C++11","slug":"C-11","permalink":"http://example.com/tags/C-11/"}]}