{"meta":{"title":"个人博客","subtitle":"daidaini的学习空间","description":"C++编程学习","author":"俞波","url":"http://example.com","root":"/"},"pages":[{"title":"Repositories","date":"2021-07-30T05:40:44.657Z","updated":"2021-07-30T05:40:44.657Z","comments":false,"path":"repository/index.html","permalink":"http://example.com/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"进程与线程","slug":"进程与线程","date":"2021-09-10T05:47:31.000Z","updated":"2021-09-10T05:50:15.416Z","comments":true,"path":"2021/09/10/进程与线程/","link":"","permalink":"http://example.com/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程与线程的区别 当我们把代码编译链接生成后的可执行文件，装载到内存中进行运行，这个运行中的实例就是进程。 同一个可执行文件，可以有多个进程实例。而且，每个进程之间的内存资源都是相互独立、互不影响的。 换句话解释就是，进程是操作系统进行资源调度和内存分配的基本单位。 这些进程独享的资源，包括有代码、打开的文件、堆、栈、存放全局变量的数据段 以及一些内核内部使用的数据，比如运行状态等。 现代的操作系统都是会并发处理多任务的，所以必然会同时处理多个进程，那就必然需要进行进程的切换。而切换进程，意味着，需要将进程独占的那些资源都进行切换。 那由于进程管理的资源较多，相对切换的成本开销就较大了。这也是引入线程的概念的原因，线程是进程的一个子任务，是用来作为操作系统进行任务调度的最小单位。 首先线程是相对进程更轻量级的存在， 单个进程的线程间共享的资源包括： 代码段 全局数据段和静态数据段 栈区 理论上，栈区是属于线程是有的。 但是实际上，不同线程的栈区并没有严格的隔离机制来进行保护。 因此，如果一个线程拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说， 这些线程可以任意膝盖本属于另一个线程中的变量。 堆区 打开的文件描述符 命令行参数 信号处理函数 进程ID、进程组ID 线程独占的资源有：（即线程上下文） 线程的栈区 栈指针?(用来指向栈顶吗？) 程序计数器（一种寄存器） 函数运行使用的寄存器（保存部分局部变量之类） TLS(Thread Local Storage) 线程间到底共享了哪些进程资源 - 知乎 (zhihu.com) 保存进程的信息的地方 称为PCB，进程控制块。 保存线程的信息的地方，就是TCB，线程控制块。 PCB存储的信息包括各种资源信息：内存地址空间信息、所有打开的文件、所有的I/O设备信息， 此外，还有进程描述符（即进程的标识，进程id），进程的运行状态，对应的用户描述符，各种寄存器的信息，以及进程的优先级（操作系统用来进行调度的算法需要）等信息。 TCB就相对少一点，除了线程描述符，也会记录对应的进程描述符，还有栈、寄存器等相关信息。","categories":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/categories/C-11/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"std-function","slug":"std-function","date":"2021-07-30T04:25:28.000Z","updated":"2021-08-02T02:31:37.177Z","comments":true,"path":"2021/07/30/std-function/","link":"","permalink":"http://example.com/2021/07/30/std-function/","excerpt":"","text":"std::function 测试实验如下： 1234567891011121314151617181920212223242526272829303132inline namespace test&#123; int FuncB(int x, int y) &#123; return x + y; &#125; struct FuncC &#123; int operator()(int x, int y) &#123; return x + y; &#125; &#125;; void test_use_function() &#123; using funcType = std::function&lt;int(int, int)&gt;; funcType a = [](int x, int y) &#123; return x + y; &#125;; funcType b = FuncB; funcType c = FuncC(); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c(30, 4) &lt;&lt; endl; &#125;&#125; 结果如下： a = 7b = 70c = 34 增加变化，加一个类如下 12345678910111213141516171819202122232425class FuncContainer &#123; public: void Push(funcType&amp;&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp;&amp; func)\\n&quot;; m_contianer.emplace_back(std::forward&lt;funcType&gt;(func)); &#125; void Push(funcType&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp; func)\\n&quot;; m_contianer.emplace_back(func); &#125; funcType&amp; Take(int index) &#123; cout &lt;&lt; &quot;using funcType&amp; Take(int index)\\n&quot;; return m_contianer[index]; &#125; private: vector&lt;funcType&gt; m_contianer; &#125;; 测试方法如下： 1234567891011121314151617void test_use_function() &#123; FuncContainer container; container.Push([](int x, int y) &#123; return x + y; &#125;); container.Push(FuncB); container.Push(FuncC()); auto afunc = container.Take(0); auto bfunc = container.Take(1); auto cfunc = container.Take(2); cout &lt;&lt; &quot;a = &quot; &lt;&lt; afunc(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; bfunc(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; cfunc(30, 4) &lt;&lt; endl; &#125; 测试结果： using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using funcType&amp; Take(int index)using funcType&amp; Take(int index)using funcType&amp; Take(int index)a = 7b = 70c = 34 实验结论： std::function 作为通用的多态函数封装器， std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针 std::function 配合using （或者typedef），可以用来作为容器的元素进行存储 std::function 作为函数参数传递时，都是作为右值引用来进行传递的 std::function 重载的 operator= 返回的是引用类型，所以，需要注意其存储元素的生命周期 参考： std::function - C++中文 - API参考文档 (apiref.com) http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E","categories":[{"name":"C++编程","slug":"C-编程","permalink":"http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/tags/C-11/"}]},{"title":"C++11线程库使用","slug":"C-11线程","date":"2021-07-30T01:59:29.000Z","updated":"2021-08-02T02:31:29.105Z","comments":true,"path":"2021/07/30/C-11线程/","link":"","permalink":"http://example.com/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"c++11线程概述关于线程池，之前交易网关这边虽然会管理多个线程，但一直没有用到线程池去管理。 前段时间，给国密的mauth服务器做一个校验账号密码的通讯组件的时候，使用了一个线程处理一个用户的校验的设计，所以尝试着去使用了线程池， 并且，他们的程序是运行在linux系统的，所以线程池也首次使用了c++11的方法去实现 c++11新增了线程库，最主要最熟知的应该就是 std::thread，以及配合以线程同步用的std::mutex和std::conditon_variable。 有了以上三个特性，我们可以很简便的实现一个跨线程的任务队列(BlockingQueue)，这个是实现线程池的基础。 所以，今天主要先分享下 c++11 线程库使用的一些方法，然后再分享下c++11的线程池实现。 std::thread使用thread库最常见的启动一个线程的方法： 1234void ThreadFunc()&#123; //do something&#125;std::thread t(ThreadFunc); 如果是带参数的线程函数，就可以： 123456void ThreadFunc(int count)&#123; //do something&#125;std::thread t(ThreadFunc, 5);//或者 使用&lt;functional&gt;中提供的 std::bind方法，将参数绑定到对应的线程函数上std::thread t(std::bind(ThreadFunc, 5)); 交易网关这边，基于std::thread实现了一个ThreadBase的类，来封装线程的启动和停止，可以参考。 关于线程的结束线程启动后，一般需要等到线程函数运行完，线程才能结束 标准库对于线程的结束也有两种方式： 1） 在主线程中调用join方法，主线程就会阻塞等待到线程函数运行完，然后结束 12if(t.joinable()) t.join() 2）调用detach方法，将线程从主线程分离。这种形式，主线程不会被阻塞，也不会知道分离出去的线程什么时候结束。 如果确定主线程肯定比线程函数晚结束，或者线程和主线程的存活时间是一致的，则可以直接在启动线程后，直接detach。 123t.detach();//简便的写法，声明和detach一起调用std::thread(ThreadFunc).detach(); thread启动线程的其他方式此外，std::thread启动线程，也可以使用lambda表达式，参考如下： 1234567std::thread([]()&#123; for (int i = 0; i &lt; 20; ++i) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; static_cast&lt;char&gt;(&#x27;A&#x27; + i) &lt;&lt; endl; this_thread::sleep_for(10ms); &#125;&#125; ); 对于将参数为引用的函数来作为线程函数，也有如下两种操作可参考： 1） 使用lambda表达式，如下： 123456789101112131415unordered_map&lt;int, string&gt; myMapSrc&#123; &#123;1, &quot;first&quot; &#125;, &#123;2, &quot;second&quot;&#125;, &#123;3, &quot;third&quot;&#125;, &#123;4, &quot;four&quot;&#125;, &#123;5, &quot;five&quot;&#125; &#125;;//捕获列表使用 &amp; 就可以std::thread([&amp;myMapSrc]()&#123; for (const auto&amp; item : myMapSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125; ).detach(); 2） 使用std::bind，如下 12345678void ThreadFunc(unordered_map&lt;int, string&gt;&amp; refRec)&#123; for (const auto&amp; item : refSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125;std::thread(std::bind(ThreadFunc, std::ref(myMapSrc))); 由于std::bind总是使用值拷贝的形式传参，哪怕函数声明为引用，std::bind传递的时候也是值传递。所以，标准库提供了std::ref来给std::bind传引用。 std::async标准库，在std::thread的基础上，封装了一些方法，有std::promise，std::pacakged_task，以及std::async。 这其中，std::promise以及std::pacakged_task的使用，一般还是要配合std::thread以及std::future来。 这边，比较推荐使用std::async来启动一个线程来执行一个异步任务，简单的示例代码如下： 123std::async(launch::async, ThreadFunc);//带参数，则std::async(launch::async, ThreadFunc, param1, param2...); std::async 方法有返回值，类型是std::future 12345678910string ThreadFuncStr(int data)&#123; this_thread::sleep_for(1s); cout &lt;&lt; &quot;This is ThreadFuncStr\\n&quot;; return to_string(data);&#125;std::future&lt;string&gt; result = std::async(launch::async, ThreadFuncStr, 100);//do some other thing string str = result.get();cout &lt;&lt; str &lt;&lt;endl; 说明： std::async， 如果第一个参数是launch::async，那就是立即启动线程任务，但是线程启动后，不会阻塞当前线程。 只有在后续调用reuslt.get()的时候，会阻塞，直到线程函数返回需要的结果。 使用建议： 推荐std::async，是因为它将thread的概念隐藏到了底层，方法本身就成为了，我就是异步去执行一个任务。 所以，如果我们一旦碰到需要读写文件或者网络请求这种涉及IO，耗时不确定可能会阻塞当前运行线程的时候，都可以调用async，来启动一个异步任务完成这部分的业务处理。 另外： 如果想使用std::thread的形式，也需要获取线程函数执行后的返回值，可以使用packaged_task，简单举例： 1234567int main()&#123; std::packaged_task&lt;string(int)&gt; task(ThreadFuncStr); std::future&lt;string&gt; async_result = task.get_future(); std::thread(std::move(task), 100).detach(); cout &lt;&lt; async_result.get() &lt;&lt; endl; return 0;&#125; 感觉用起来，不如std::async方便，感兴趣的可以自行研究(报考std::promise 也是，它们都有各自的应用场景)。 线程池有执行一个异步任务来获取结果的需求，肯定也有不定时执行多个异步任务的需求。 最典型的就是，服务端处理多个不同用户的业务逻辑的场景： 1）每个用户的业务处理，一般都需要在自己独立的线程中运行； 2）线程处理完一个用户的业务逻辑，还可以处理另一个用户的业务逻辑。 这种情况，就比较适合用线程池了。 下边就是用C++11标准库实现的线程池的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class FixedThreadPool&#123;public: using FuncTaskType = std::function&lt;void()&gt;; FixedThreadPool(size_t threadCount) : m_ResData(make_shared&lt;ResInfo&gt;()) &#123; for (size_t i = 0; i &lt; threadCount; ++i) &#123; std::thread(std::bind(&amp;FixedThreadPool::ThreadFunc, this)).detach(); &#125; &#125; ~FixedThreadPool() &#123; if (m_ResData != nullptr) &#123; std::lock_guard&lt;std::mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;IsShutdown = true; &#125; m_ResData-&gt;Cv.notify_all(); &#125; void Execute(FuncTaskType&amp;&amp; task) &#123; lock_guard&lt;mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;Tasks.emplace(std::forward&lt;FuncTaskType&gt;(task)); m_ResData-&gt;Cv.notify_one(); &#125;private: void ThreadFunc() &#123; unique_lock&lt;mutex&gt; lk(m_ResData-&gt;Mtx); do &#123; if (!m_ResData-&gt;Tasks.empty()) &#123; auto currentTask = std::move(m_ResData-&gt;Tasks.front()); m_ResData-&gt;Tasks.pop(); lk.unlock(); currentTask(); lk.lock(); &#125; else if (m_ResData-&gt;IsShutdown) &#123; break; &#125; else &#123; m_ResData-&gt;Cv.wait(lk); &#125; &#125; while (true); &#125; struct ResInfo &#123; mutex Mtx; condition_variable Cv; bool IsShutdown = false; //线程函数任务队列 queue&lt;FuncTaskType&gt; Tasks; &#125;; std::shared_ptr&lt;ResInfo&gt; m_ResData;&#125;; 简单解释： ResInfo 是需要的一些信息，包含线程同步用互斥量和条件变量，线程池的开关，以及存储线程任务的队列 ResInfo 使用 shared_ptr 是因为 每个线程都会进行一份拷贝 存储队列，使用queue，满足先进先出 线程任务，统一使用 函数模板 std::function&lt;void()&gt; ，这样，后续再配合std::bind，就可以执行所有带参数和不带参数的线程函数 构造的时候，直接启动对应数量的线程，每个线程的运行都封装在ThreadFunc ThreadFunc 使用unique_lock 一是需要配合条件变量进行wait， 二是，在将线程任务从队列中取出来之后，就不需要再锁了，可以unlock。 对于线程池内部的mutex，它用来保护的数据，其实就是线程任务队列，所以将线程任务从队列中取出来之后，这个锁的任务就达成了。 执行完线程任务，再锁住，是该线程在循环，执行完上一个任务，就会去队列中取下一个任务。 Execute方法，顾名思义，就是用来执行任务的。右值引用作为参数进行传递时，会转换成左值，需配合完美转发std::forward使用 最后，析构函数，主要是确保开关置为true，启动的线程函数可以正常运行结束。 参考: C++11 (三) - std::function、std::bind、std::ref C++11 std::thread detach()与join()用法总结 《Linux多线程服务端编程》","categories":[{"name":"C++编程","slug":"C-编程","permalink":"http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/tags/C-11/"}]},{"title":"Hello World","slug":"hello-world","date":"2021-07-30T01:53:10.230Z","updated":"2021-07-30T01:53:10.230Z","comments":true,"path":"2021/07/30/hello-world/","link":"","permalink":"http://example.com/2021/07/30/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new &quot;My New Post&quot; More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[{"name":"C++11","slug":"C-11","permalink":"http://example.com/categories/C-11/"},{"name":"C++编程","slug":"C-编程","permalink":"http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"C++11","slug":"C-11","permalink":"http://example.com/tags/C-11/"}]}