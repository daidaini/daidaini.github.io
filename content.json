{"meta":{"title":"个人博客","subtitle":"daidaini的学习空间","description":"程序员记录学习内容的地方","author":"daidaini","url":"https://daidaini.github.io","root":"/"},"pages":[{"title":"分类","date":"2021-07-30T05:40:44.656Z","updated":"2021-07-30T05:40:44.656Z","comments":false,"path":"categories/index.html","permalink":"https://daidaini.github.io/categories/index.html","excerpt":"","text":""},{"title":"标签","date":"2021-07-30T05:40:44.657Z","updated":"2021-07-30T05:40:44.657Z","comments":false,"path":"tags/index.html","permalink":"https://daidaini.github.io/tags/index.html","excerpt":"","text":""},{"title":"Repositories","date":"2023-01-30T03:31:09.618Z","updated":"2021-07-30T05:40:44.657Z","comments":false,"path":"repository/index.html","permalink":"https://daidaini.github.io/repository/index.html","excerpt":"","text":""}],"posts":[{"title":"回调函数的理解","slug":"回调函数的理解","date":"2023-02-09T02:30:40.000Z","updated":"2023-02-09T02:31:13.531Z","comments":true,"path":"2023/02/09/回调函数的理解/","link":"","permalink":"https://daidaini.github.io/2023/02/09/%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"回调函数的基本定义回调函数定义上来说，指的就是作为另外一个函数的参数的函数。 实现原理，可以简单概括为： 存在一个函数，它的入参中有一个函数指针（能传入函数地址即可）。顺序执行函数内部代码时，在适合的时候使用这个函数指针，以达到希望的结果。（比如，传出某些计算出来的数据，或者生成某些需要给其他调用者的信息等） C语言中的回调函数大多都是 void*的形式存在，而void*指代的即是回调函数的函数指针。 如下示例： 1234567891011121314int Sum(int a, int b)&#123; return a+b;&#125;//cbfunc，用以传入函数指针void SomeFunc(void* cbfunc, int param1, int param2)&#123; ... int result = cbfunc(param1, param2); ...&#125;//调用SomeFunc(Sum, 2, 5); 回调函数的作用延迟执行回调函数的这个用处，可以从上述代码中就能略知一二。调用SomeFunc函数的时候传入了Sum方法，但是Sum方法的执行却需要在函数内部执行到对应代码的时候。 此外，我们平时使用的标准库的算法，大多也是处于这种目的来使用回调函数。 1234567891011std::vector&lt;std::string&gt; vec&#123; &quot;abcdef&quot;, &quot;123456&quot;, &quot;abcdef123456&quot;, &quot;123456abcdef&quot;&#125;;std::for_each(vec.begin(), vec.end(), [](const std::string &amp;str) &#123; if (str.length() &gt; 10) &#123; std::cout &lt;&lt; str &lt;&lt; &#x27;\\n&#x27;; &#125; &#125;); 标准库的算法，大多都是类似上述的方法，通过Lambda函数作为回调函数的形式来完成使用。 分离调用者和被调用者回调函数可以使调用者不需要关心谁是被调用者，只需要知道，存在一个具有某种特定原型、某些限制条件的被调用函数。 回调函数的这个作用，通常可用于不同模块之间的异步数据通知。 而怎么使用回调函数达到这个设计，在C++中有多种模式，除了上边已经提到的函数指针和lambda函数，还可以使用函数模板std::funciton 或者纯虚抽象类的形式。 std::function123456789101112131415161718192021222324252627282930313233343536373839class Callback&#123;public: void OnResponse(const char *data, int len) &#123; cout &lt;&lt; &quot;Calling OnResponse :&quot;; cout &lt;&lt; std::string(data, len) &lt;&lt; endl; &#125; Callback() = default; ~Callback() = default;&#125;;typedef std::function&lt;void(const char *, int)&gt; OnRspFuncType;class Client&#123;public: void RegisterCallback(OnRspFuncType func) &#123; onRspFunc_ = std::move(func); &#125; void Running() &#123; for (int i = 0; i &lt; 100; ++i) &#123; this_thread::sleep_for(chrono::milliseconds(i)); if (i % 20 == 5) &#123; std::string content = fmt::format(&quot;SendBack: &#123;&#125;&quot;, i); onRspFunc_(content.data(), (int)content.length()); &#125; &#125; &#125;private: OnRspFuncType onRspFunc_;&#125;; 上述例子使用c++11的 std::function 来定义回调函数的类型。std::function 配合 std::bind使用，可以达到回调函数的参数传递的目的。相对直接使用函数指针，这么使用至少可以保证类型安全，且编译器的检查可以确保调用正确。 使用上述回调类的代码如下： 1234567void Test()&#123; Callback cb; Client cli; cli.RegisterCallback(std::bind(&amp;Callback::OnResponse, &amp;cb, placeholders::_1, placeholders::_2)); cli.Running();&#125; 纯虚抽象类当然，除了上述的 函数指针、lambda函数、std::function这些，我们平时比较常见的使用回调函数的形式是纯虚的抽象类接口的形式。 举个例子来说明下纯虚类对回调函数的使用： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556//纯虚抽象类定义class CallbackInterface&#123;public: virtual void OnResponse(const char *data, int len)&#123;&#125; virtual ~CallbackInterface()&#123;&#125;&#125;;//被调用者继承抽象类，实现具体回调class Callback : public CallbackInterface&#123;public: void OnResponse(const char *data, int len) &#123; cout &lt;&lt; &quot;Calling OnResponse :&quot;; cout &lt;&lt; std::string(data, len) &lt;&lt; endl; &#125; Callback() = default; ~Callback() = default;&#125;;//调用者代码class Client&#123;public: void RegisterCallback(CallbackInterface* cb) &#123; cb_ = cb; &#125; //模拟使用回调函数 void Running() &#123; for (int i = 0; i &lt; 100; ++i) &#123; this_thread::sleep_for(chrono::milliseconds(i)); if (i % 20 == 5) &#123; std::string content = fmt::format(&quot;SendBack: &#123;&#125;&quot;, i); cb_-&gt;OnResponse(content.data(), (int)content.length()); // error &#125; &#125; &#125;private: CallbackInterface *cb_;&#125;;void Test()&#123; Client cli; CallbackInterface* cb = new Callback; cli.RegisterCallback(cb); cli.Running();&#125; 这里这个回调类只声明了一个回调函数，因此可能感觉使用纯虚类有一点迂回。但如果是需要多个回调函数的场景，使用这种方式的话，就比较简便了，（因为注册的调用只需要一次即可）。 最后补充一点，C++里的纯虚函数，在Java里其实就是Interace，顾名思义，够明显了。","categories":[{"name":"C++11","slug":"C-11","permalink":"https://daidaini.github.io/categories/C-11/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"https://daidaini.github.io/tags/C-%E5%AD%A6%E4%B9%A0/"}]},{"title":"二分法的理解","slug":"二分法的理解","date":"2023-02-06T16:00:00.000Z","updated":"2023-02-07T05:39:13.791Z","comments":true,"path":"2023/02/07/二分法的理解/","link":"","permalink":"https://daidaini.github.io/2023/02/07/%E4%BA%8C%E5%88%86%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"使用循环实现先看一道leetcode上的题：在排序数组中查找元素的第一个和最后一个位置 题目明确要求 实现的时间复杂度为 O(log n)。这个要求，很容易让我们联想到二分法这个算法。再拆解下题目描述，已经是有序数组，满足二分查找的前提，那么只需要通过二分法找到目标元素的位置，再向前后迭代获取最左和最右的索引即是题目所需要的答案。 列一下所实现的二分查找的代码： 12345678910111213141516171819202122232425//只返回查找到的位置，不确定是最左或最右int BinarySearch(vector&lt;int&gt;&amp; nums, int target)&#123; assert(nums.size() &gt;= 2); int left = 0; int right = nums.size() - 1; while (left &lt;= right) &#123; int mid = (right + left) / 2; int midval = nums[mid]; if (midval &lt; target) //往右折 &#123; left = mid + 1; //由于left &lt;= mid ，所以要确保left右移需要加1 &#125; else if (midval &gt; target) //往左折 &#123; right = mid - 1; //由于mid&lt;right, 必会使right左移，但这里mid已经检查过一遍，最差情况会导致再检查一次， &#125; else &#123; return mid; &#125; &#125; return -1;&#125; 代码理解: 二分查找需要确定区间，每次折半，所以需要定义左右端点位置 left、right 在循环内逐步缩小区间，结束区间的条件定为 left&lt;=right，意为在left==right还要进行一次判断，该值是不是target目标值 折半查找，需要定义mid位置，mid = (right+left)/2，这样做的话，在left&lt;right时，必然会有mid&lt;right，mid&gt;=left条件的成立 将mid位置的值与target进行比较，三种情况分别处理。 相等则返回，表示已查找到 中值小于target值，表示target值在右区间，需要将left端点右移，left = mid+1，需要加1，这样的最极端情况是left==right，循环后再判断一次即可 中值大于target值，表示target值在左区间，需要将right端点左移，right = mid-1，减1，这样的最极端情况是left==mid的时候，这种情况的时候表示无法左移了，那么right==mid-1==left-1，会退出循环，也是不存在遗漏查找的情况 默认返回-1，表示查找不到；如果查找到，会直接在循环中就返回 值得注意的是，如果代码如上，那么mid = (right+left)/2 和 mid = (right+left+1)/2 两种情况的处理没有区别。 使用递归实现依然通过leetcode上一个题来举例：搜索旋转排序数组 II旋转后的数组是没法保证折半之后左右区间都是肯定满足左区间的数小于等于右区间的数的忽略一些细节的判断，我们可以简单的在折半之后两边都进行查找，这样的话，使用递归方法来实现会使代码简单直观很多。 1234567891011121314151617181920int BinarySearch(vector&lt;int&gt;&amp; nums, int target, int left, int right)&#123; if (left &gt; right) &#123; return -1; &#125; int mid = (left + right) / 2; int midval = nums[mid]; if (midval == target) &#123; return mid; &#125; int result = BinarySearch(nums, target, mid + 1, right); if (result != -1) &#123; return result; &#125; return BinarySearch(nums, target, left, mid - 1);&#125; 然后简但调用就可以达到查找的目的 123bool search(vector&lt;int&gt;&amp; nums, int target) &#123; return BinarySearch(nums, target, 0, nums.size() - 1) != -1;&#125; 二分折半的思想是共通的，注意临界点的情况即可。","categories":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://daidaini.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}],"tags":[{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://daidaini.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"}]},{"title":"C指针的理解","slug":"指针的理解","date":"2023-01-30T16:00:00.000Z","updated":"2023-02-09T02:26:51.892Z","comments":true,"path":"2023/01/31/指针的理解/","link":"","permalink":"https://daidaini.github.io/2023/01/31/%E6%8C%87%E9%92%88%E7%9A%84%E7%90%86%E8%A7%A3/","excerpt":"","text":"简单的指针的声明一般有如下形式 123int* ptr = new int;int data = 100;int* iptr = &amp;data; 以下尝试使用c++的思想来理解下c指针的相关内容。int* 这种可以理解为是整型指针类型，那么iptr就是整型指针类型的变量，iptr本身是左值，能取到地址，因此二级指针也就存在意义: 1int** iiptr = &amp;iptr; 指针类型的变量是用来存储地址数据的，因此一般是整型的，什么长度的整型跟机器是32位还是64位关联。指针变量的值对应的地址则是用来表示存储的数据的。 123456*ptr = 101;printf(&quot;%d\\n&quot;, **iiptr);**iiptr = 111;printf(&quot;%d\\n&quot;, *iptr);assert(*iptr == **iiptr);assert(&amp;iptr == iiptr); 所以： 一级指针的值是地址，就是表示存储数据的的变量的地址 二级指针的值也是地址，就是表示一级指针的这个变量的地址 那同样的思路，对于指针数组，可以写如下代码 12345char* cptr = new char[256];strcpy(cptr, &quot;abcdefg&quot;);char** ccptr = &amp;cptr;assert(*cptr, &#x27;a&#x27;);printf(&quot;%c, %c, %c\\n&quot;, **ccptr, *cptr + 1, **ccptr + 2); 接着是对函数指针的理解。函数指针一般以这种方式声明： 1typedef int (*funcptr)(int, int); 如果有以下满足函数指针声明类型的函数 123456int Add(int a, int b)&#123; return a + b;&#125;int Sub(int a, int b)&#123; return a -b;&#125; 简单的使用函数指针来表示函数如下： 123456funcptr somefunc = Add;printf(&quot;%p\\n&quot;, somefunc);printf(&quot;%d\\n&quot;, somefunc(20, 10));somefunc = Sub;printf(&quot;%p\\n&quot;, somefunc);printf(&quot;%d\\n&quot;, somefunc(20, 10)); 这里的函数指针类型变量somefunc的值就是要表示的函数的地址。既然somefunc是表示值的变量，即使它是指针，它也可以取到地址，那就可以使用二级指针来表示这个指针类型变量的地址。 123456decltype(&amp;somefunc) ptr_somefunc = &amp;somefunc;printf(&quot;%p\\n&quot;, ptr_somefunc);printf(&quot;%d\\n&quot;, (*ptr_somefunc)(30, 10));*ptr_somefunc = Add;printf(&quot;%p\\n&quot;, ptr_somefunc);printf(&quot;%d\\n&quot;, (*ptr_somefunc)(30, 10)); 这里使用decltype只是为了简化代码，省略一个二级函数指针的定义，否则需要： 12typedef int (**pfuncptr)(int, int);pfuncptr ptr_somefunc = &amp;somefunc; 此外，可以确认两次打印二级函数指针的地址是一样的，因为它表示的是ptr_somefunc变量的地址。","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C语言","slug":"C语言","permalink":"https://daidaini.github.io/tags/C%E8%AF%AD%E8%A8%80/"}]},{"title":"理解CPP的移动语义","slug":"理解CPP的移动语义","date":"2023-01-30T16:00:00.000Z","updated":"2023-02-02T03:42:25.236Z","comments":true,"path":"2023/01/31/理解CPP的移动语义/","link":"","permalink":"https://daidaini.github.io/2023/01/31/%E7%90%86%E8%A7%A3CPP%E7%9A%84%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89/","excerpt":"","text":"什么是移动语义移动语义是从C++11标准开始支持的，那什么是移动语义呢？ 先引用下《Effective Modern C++》中关于移动语义的说明 Move semantics makes it possible for compilers to replace expensive copying operations with less expensive moves. In the same way that copy constructors and copy assignment operators give you control over what it means to copy objects, move constructors and move assignment operators offer control over the semantics of moving. Move semantics also enables the creation of move-only types, such as std::unique_ptr, std::future, and std::thread. 提取下关键信息就是：移动语义让编译器在需要拷贝对象时可以使用一种代价更低的移动的方式来执行。拷贝对象是通过拷贝构造和拷贝赋值，移动对象是通过移动构造和移动赋值。此外，移动语义还可以处理只能移动的对象的构造。 以下为个人理解：移动语义的直接作用对象是函数的参数，发生移动的最直接的场景就是对自定义类型的参数进行传递的时候。当参数是作为右值形式进行传递时，会调用该类型的移动构造函数(或移动赋值)以构造临时对象，举例说明。 123456789101112131415161718192021222324class A&#123;public: A() = default; A(A&amp;&amp; rhs) noexcept &#123; cout &lt;&lt; &quot;using move construct.\\n&quot;; &#125; A&amp; operator=(A&amp;&amp; rhs) noexcept &#123; cout &lt;&lt; &quot;using move assign.\\n&quot;; return *this; &#125;&#125;;void func(A param)&#123; cout &lt;&lt; &quot;using func.\\n&quot;; A a1; a1 = std::move(param); //调用移动赋值&#125;void test()&#123; A a; // func(a); //error. func(std::move(a)); //通过移动构造构建临时对象&#125; 输出如下： 123using move construct.using func...using move assign. 例子解释： A(A&amp;&amp; rhs) 这是移动构造函数的声明方式 A&amp; operator=(A&amp;&amp; rhs) 这是移动赋值函数的声明方式 std::move(param) 使用std::move可以将参数强制转换为右值形式。 func函数是使用值传递的方式，因此传参时会构造临时对象，由于参数转为了右值类型，因此会调用移动构造方法(打印了using move construct) 不能直接使用func(a)，因为在显示声明了移动构造函数后，编译器就不会自动生成拷贝构造函数了 可见，虽然上述例子是最简单的使用移动语义的场景，但依然会不可避免的涉及到几个概念的理解： 左值和右值怎么区分 移动构造函数以及移动赋值函数 std::move强转右值，std::forward完美转发 我们可能还会考虑一个问题，函数传参除了值传递，还有引用传递，引用传递有单引用也有双引用，除了引用传递，此外还有使用指针传递，这些传递方式在移动语义的表现上都有什么区别呢？ 移动拷贝和移动赋值对于移动拷贝函数和移动赋值函数，其实上边的例子已经有简单的说明，其形式就是： 12A(A&amp;&amp; rhs)A&amp; operator=(A&amp;&amp; rhs) 移动和拷贝的最大区别在于实现，拷贝要么就是深拷贝要么就是浅拷贝，而移动就真的就是移动掉了，不存在拷贝。它们的开销代价也因此而来。举一个例子说明： 写一个MyString类，为简单阐述，只实现了拷贝赋值和移动赋值 1234567891011121314151617181920212223242526272829303132333435363738394041class MyString final&#123;public: MyString() &#123; data_ = new char[1024]; &#125; ~MyString() &#123; if (data_ != nullptr) &#123; delete data_; data_ = nullptr; &#125; &#125; MyString&amp; operator=(const MyString&amp; rhs)&#123; if (rhs.data_ == nullptr || data_ == nullptr) return *this; cout &lt;&lt; &quot;copy assigning..\\n&quot;; ::memcpy(this-&gt;data_, rhs.data_, 1024); return *this; &#125; MyString&amp; operator=(MyString&amp;&amp; rhs) noexcept &#123; if (rhs.data_ == nullptr || data_ == nullptr) return *this; cout &lt;&lt; &quot;move assigning..\\n&quot;; data_ = rhs.data_; rhs.data_ = nullptr; return *this; &#125; bool Empty() const&#123; return data_ == nullptr; &#125;private: char* data_ = nullptr;&#125;; 这个类，目的是在拷贝赋值时是深拷贝，在移动赋值时仅仅是移动，通过测试函数进行验证 123456789void Test()&#123; MyString s1; MyString s2; s1 = s2; assert(!s2.Empty()); s1 = std::move(s2); assert(s2.Empty());&#125; 输出结果 12copy assigning..move assigning.. 左值右值概念左值右值的概念可以总结概括为： 左值指表达式结束后依然存在的持久对象，可以取到地址，比如具名变量或者对象实例 右值是表达式结束后就不再存在的临时对象，不可以取到地址，没有名字 所以区分是左值还是右值，一个最有用的步骤即使看能否取到它的地址，如果可以就是左值，不可以则通常是一个右值。此外，概念上来说，右值通常就是从方法中返回的临时对象（非绝对），而左值对应的就是实际可以指向的对象，不管是通过指针还是引用的形式。 右值还可以细分为纯右值(pure rvalue)和将亡值(expiring value)。 纯右值： 非引用返回的临时变量 运算表达式产生的临时变量 原始字面量 lambda表达式 将亡值：可以理解为将要被销毁，但是可以被移动的值 1234567void func(std::vector&lt;int&gt;&amp; vec)&#123; //此处expiring就是一个将亡值 //因为std::string 对象可以移动，因此最后会调用移动赋值函数将expiring的值移动到str中 std::vector&lt;int&gt; expiring&#123;1, 2, 3, 4&#125;; vec = std::move(expiring);&#125; 右值引用使用符号&amp;&amp; 表示右值引用。 123int a = 100;int &amp;&amp;r1 = std::move(a);//int &amp;&amp;r1 = a; //error! 但是使用带&amp;&amp;的类型表示的变量，不一定就是右值，按照左值的定义，只要具名的能取到地址的变量就是左值，所以即使你使用&amp;&amp;来声明，该是左值的还是左值。 1234void func(int&amp;&amp; param) &#123; //int&amp;&amp; r1 = param; //error! param是左值! int&amp;&amp; r1 = std::move(param);&#125; 此外，有一种特殊情况，《Effective Modern C++》中将其称为 **universal references(通用引用)**，看几个示例: 1234567891011void func(std::vector&lt;int&gt;&amp;&amp; param); //右值引用std::vector&lt;int&gt;&amp;&amp; vec1 = std::vector&lt;int&gt;&#123;&#125;; //右值引用auto&amp;&amp; vec2 = vec1; //非右值引用template&lt;typename T&gt;void func(std::vector&lt;T&gt;&amp;&amp; param); //右值引用，不是T&amp;&amp;的形式，不是universal referencetemplate&lt;typename T&gt;void func(T&amp;&amp; param) //非右值引用 首先，universal reference必须是 T&amp;&amp; 的形式，且必须存在类型推导。以上两个非右值引用的场景是最典型的两个universal references的场景。 至于universal reference怎么判断是左值引用还是右值引用，需要进一步看它的构造者(即实际的传参)，如下示例： 1234567template&lt;typename T&gt;void func(T&amp;&amp; param); //param是一个 universal referencestd::vector&lt;int&gt; vec;func(vec); //传参是左值，所以T&amp;&amp;对应的是左值引用 std::vector&lt;int&gt;&amp;func(std::move(vec)); //传参是右值，所以param的类型是 std::vector&lt;int&gt;&amp;&amp; 应用先明确，对于性能而言，纯C指针的性能肯定是没话说的，即使移动语义可以减少一些消耗，但还是不能完全达到C指针直接操作内存的效率。但也需要明确，C指针的不安全性，是很多复杂问题的根源，标准库引入了各种智能指针，其实就是在提供方法尽量避免使用裸C指针。移动语义的引入，在我看来是想在安全性和性能之间找到一种尽可能的平衡。 区分了左值右值，也知道了移动构造和移动赋值的作用，那移动语义我们平时怎么去应用呢？其实，现在的标准库中，基本上所有的容器都已经了支持移动语义，再配合现代编译器普遍支持的RVO机制，我们可以更简洁明确的编写代码，而不用使用指针或者左值引用来既表示出参，又表示入参。 一个简单的队列的示例1234567891011121314151617181920template&lt;typename T&gt;class DemoQueue&#123;public: void Insert(T&amp;&amp; task) &#123; tasks_.push(std::move(task)); //T&amp;&amp; task 模板展开后就不再需要自动推导，所以不是universal reference &#125; T Get() &#123; T t = std::move(tasks_.front()); //front()返回的是左值引用，由于该元素后续会被移除(pop)，属于将亡值 tasks_.pop(); return t; //RVO 返回时不会再拷贝临时对象 &#125;private: std::queue&lt;T&gt; tasks_;&#125;; 12345678910void Test()&#123; TaskQueue&lt;std::string&gt; q1; q1.Insert(&quot;first&quot;s); q1.Insert(&quot;second&quot;s); q1.Insert(&quot;third&quot;s); assert(q1.Get() == &quot;first&quot;); assert(q1.Get() == &quot;second&quot;);&#125; 完美转发和通用引用123456789101112131415161718192021template&lt;typename T&gt;auto Merge(T&amp;&amp; a, T&amp;&amp; b)&#123; if (std::is_lvalue_reference&lt;T&amp;&amp;&gt;::value) &#123; cout &lt;&lt; &quot;左值\\n&quot;; &#125; else if (std::is_rvalue_reference&lt;T&amp;&amp;&gt;::value) &#123; cout &lt;&lt; &quot;右值\\n&quot;; &#125; return std::forward&lt;T&gt;(a) + std::forward&lt;T&gt;(b);&#125;void Test()&#123; int a = 10, b = 20; cout &lt;&lt; Merge(a, b) &lt;&lt; endl; std::string s1&#123; &quot;one &quot; &#125;; std::string s2&#123; &quot;two &quot; &#125;; cout &lt;&lt; Merge(std::move(s1), std::move(s2)) &lt;&lt; endl;&#125; 输出结果: 1234左值30右值one two 可以看到，Merge方法在调用时才会根据传参进行类型推导到底传入的是左值引用还是右值引用。所以，这边的std::forward就是起到了转发的作用，将传入参数的具体左值右值类型传递了下去。 备注：std::is_lvalue_reference这样的判断类型的模板，都在标准库头文件中定义，这个头文件中还有许多其他有用的方法值得学习了解。 总结理解了移动语义，可以帮助更容易以更有效率的方式使用标准库中的各种容器和模板。也可以在自定义类中使用包含数据量大的数据结构时，有多一种提高性能表现的方法。","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++特性","slug":"C-特性","permalink":"https://daidaini.github.io/tags/C-%E7%89%B9%E6%80%A7/"}]},{"title":"常用Linux命令","slug":"常用Linux命令","date":"2022-03-23T13:14:28.000Z","updated":"2023-01-31T07:21:51.025Z","comments":true,"path":"2022/03/23/常用Linux命令/","link":"","permalink":"https://daidaini.github.io/2022/03/23/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/","excerpt":"","text":"文件操作相关 chmodchmod有两种操作方式,一种为普通授权法： 1234chmod +x a.txt #给a.txt可执行的权限chmod +r a.txt #给a.txt可读的权限 文件权限，’r’ 代表可读(4)，’w’代表可写(2)， ‘x’代表可执行(1) 上面括号内的数字 代表 “8421法”，即第二种操作方式。 12chmod 777 a.txt #表示给a.txt所有权限 关于文件的权限信息说明： -r-xr-xr-x 1 yubo yubo 342 May 27 22:06 hello.sh* 前面的 “-r-xr-xr-x” 即对应文件的权限信息。 其中，第一位是’-‘ 这个表示文件， 如果是’d’就表示文件夹； 后面分为三组，分别表示 “拥有者的权限”，“拥有者所在的组、组员的权限”，“其他用户的权限”； 每一组的权限，都是三位，分别代表 读写和执行的权限，所以，如果三个权限都有，就稳定为 “rwx”。 对上述文件，修改，使文件所有者有 所有权限： 123chmod 755 hello.sh$ll$-rwxr-xr-x 1 yubo yubo 342 May 27 22:06 hello.sh* [Linux]创建新用户及用户权限 - 知乎 (zhihu.com) sudosudo 命令 以系统管理者的身份执行，也就是说，经由sudo执行的命令就好像 是 root亲自执行。需要输入自己的账户密码。使用权限: 在 /etc/sudoers 中出现的使用者 12#以yao用户身份编辑 home目录下的index.html文件$ sudo -u yao vi ~www/index.html 编辑文件命令: vi 和 vim 操作： vi + 文件名 进入后，操作界面有三种模式：命令模式、插入模式和底行模式 三种模式相关定义： 命令模式 刚进入文件就是命令模式，通过方向键控制光标位置， 使用命令”dd”删除当前整行 使用命令”/字段”进行查找 按”i”在光标所在字符前开始插入 按”a”在光标所在字符后开始插入 按”o”在光标所在行的下面另起一新行插入 按”：”进入底行模式 插入模式 此时可以对文件内容进行编辑，左下角会显示 “– 插入 –”” 按”ESC”进入底行模式 底行模式 退出编辑 :q 强制退出 :q! 保存并退出 :wq 操作步骤示例 保存并退出编辑 “ESC” -&gt; 输入”:” -&gt; 输入”wq”,回车 取消操作：按”ESC” -&gt; 输入”:” -&gt; 输入”q!”,回车 补充 1234vim +10 filename.txt #打开文件并跳到第10行vim -R /etc/passwd #以只读模式打开文件 文件创建查看删除123456789101112131415#创建文件touch a.txt#移动文件mv [选项] 文件名 [目标文件名|目标路径]#复制文件cp [选项] 源文件 目标文件#复制文件夹cp -r dir1 dir2#删文件 -f 忽略警告信息 -i 删除前先询问rm [选项] 文件#删除文件夹 rm -r 目录名#重命名rename libfmt.a libfmt.a.bak libfmt.a diff显示两个文件的差异 1diff -c file1 file2 压缩/解压文件 tar[选项][文件] 1234#打包并压缩文件，压缩包后缀为 .tar.gztar -czvf *.tar.gz#解压并展开压缩包，压缩包后缀为 .tar.gztar -xzvf *.tar.gz 具体参数参考如下： 参数 作用 -c 创建压缩文件 -x 解开压缩文件 -t 查看压缩包内有哪些文件 -z 用Gzip压缩或者解压 -j 用bip2压缩或者解压 -v 显示压缩或者解压的过程 -f 目标文件名 -p 保留原始的权限和属性 -P 使用绝对路径来压缩 -C 指定解压到的目录 查找文件find12345678910111213141516find /bin -name &#x27;a*&#x27; #查找bin目录下所有以a开头的文件或者目录find . -name &#x27;*.c&#x27; #将当前目录及其子目录下，所有.c文件找出来find . -type f#将当前目录及其子目录下的所有一般文件列出find . -ctime -20#将当前目录及其子目录下 所有最近20天更新过的文件列出find . -type f -perm 664 -exec ls -l &#123;&#125; \\;#将当前目录及其子目录下， 所有权限为664的文件，列出#解释：这个命令可以分为两部分看，前半部分，到 -perm 664表示是查看文件的信息的权限；#后半部分，表示从执行ls -l 命令获取到的信息中进行筛选。 find工具笔记 whereis将和ls命令相关的文件都找出来 参数是某个命令（验证过 cmake ssh等） 1whereis ls whichwhich指令 会在环境变量 $PATH 设置的目录里查找符合条件的文件 1which is bash grep grep [选项] [文件] 12345#在文件中查找字符串（不区分大小写）grep -i &quot;the&quot; demo_file #在一个文件夹中递归查询包括指定字符串的文件grep -r &quot;remesh&quot; * 参数 作用 -b 将可执行文件(binary) 当作文本文件(txt)来搜索 -c 仅显示查找到的次数 -i 忽略大小写 -n 显示行号 -v 反向选择–仅列出没有“关键词”的行 下载文件wget12345#该命令用于从网上下载内容wget http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz#下载文件并以指定的文件名保存文件wget -O nagios.tar.gz http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz ftp12ftp IP/hostname //访问ftp服务器mls *.html - //显示远程主机上文件列表 scp通过scp命令在多台服务器中相互复制、传输文件(secure copy的缩写)scp 是linux系统下基于ssh登录进行安全的远程文件拷贝命令scp是加密的， rcp是不加密的， scp是rcp的加强版本 12scp /opt/data.txt 192.168.1.101:/opt/ #将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下 网络操作防火墙操作123456service iptables status //查看iptables服务的状态service iptables start //开启iptables服务service iptables stop //停止iptables服务service iptables restart //重启iptables服务chkconfig iptables off //关闭iptables服务的开机自启动chkconfig iptables on //开启iptables服务的开机自启动 查看网络信息123456789ifconfig#查看与IP的连接情况ping IP #查看当前系统端口netstat -an #查看指定端口netstat -an | grep 8080 #远程主机，需要输入用户名密码ssh IP lsof列出当前系统打开的文件描述符（list openfiles） 123456789101112#仅显示TCP连接（同理UDP）lsof -iTCP#显示与指定端口相关的网络信息lsof -i:3322#显示指定到指定主机的连接lsof -i@192.168.6.25#加端口lsof -i@192.168.6.25:23386#找出监听端口lsof -i -sTCP:LISTENlsof -i | grep -i LISTEN Linux 命令神器：lsof 修改IP修改网络配置文件，文件地址为 /etc/sysconfig/network-scripts/ifcfg-eth0 主要对应以下配置： 123456789TYPE=Ethernet //网络类型BOOTPROTO=static //静态IPDEVICE=ens00 //网卡名IPADDR=192.168.1.100 //设置的IPNETMASK=255.255.255.0 //子网掩码GATEWAY=192.168.1.1 //网关DNS1=192.168.1.1 //DNSDNS2=8.8.8.8 //备用DNSONBOOT=yes //系统启动时启动此设置 修改以后，使用命令重启网卡 1service network restart 配置映射修改文件 vi /etc/hosts在文件最后添加映射地址，示例如下： 123192.168.1.101 node1192.168.1.102 node2192.168.1.103 node3 配置好以后保存退出，输入命令：ping node1 ，可见实际 ping 的是 192.168.1.101。 tcpdump抓包分析工具使用tcpdump抓包 查看系统信息 1234#查看操作系统版本信息cat /proc/version#显示一些重要的系统信息，例如：内核名称、主机名、内核版本号、处理器类型之类信息uname -a 进程信息123456#查看所有正在运行的进程ps -ef#杀死pid进程kill pid#强制杀死该进程kill -9 pid service12345#service命令用于运行System V init脚本，这些脚本一般位于/etc/init.d 文件中#该命令可以直接运行脚本，而不需要加上路径service ssh status #查看服务状态service --status-all #查看所有服务状态service ssh restart #重启服务 free123#这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况free -g #以g为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节free -t #查看所有内存的汇总 top显示当前系统中占用资源最多的一些进程，shift+m 按照内存大小进行排序 df12#显示文件系统的磁盘使用情况df -h 环境变量12345678#查看当前环境变量echo $PATH#设置环境变量值export PATH=#添加一个路径export PATH=$PATH:newdir watch用于动态查看命令执行的结果比如，如果想要每隔一秒高亮显示 网络连接数的变化情况，则： 1watch -n 1 -d netstat -ant 每隔一秒高亮显示 http 连接数的变化情况 1watch -n 1 -d &#x27;pstree | grep http&#x27; vmstat常用系统性能分析工具，主要用来分析系统的内存使用情况，也常用来分析CPU上下文切换和中断的次数 其它 创建新用户root权限下，使用 useradd 命令进行 123useradd -m daidaini -c &quot;test creating a new user&quot;#指定密码passwd daidaini *** nohupno hang up 的缩写，不要挂起的意思，这个是常用的后台启动程序的方法。 在交互环境下，我们可以直接将一些信息输出到当前界面；那后台启动的程序，我们就会通常使用下边的命令，指定将信息输出到某个文件 1nohup command &gt; some.file 2&gt;&amp;1 &amp; 命令解释 1 表示标准输出 2 表示文件标准错误输出 2&gt;1&amp; 表示将两者合并，合并到的文件为some.file 常见命令","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://daidaini.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://daidaini.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"Linux多线程服务端编程","slug":"《Linux多线程服务端编程》阅读笔记","date":"2022-03-23T12:50:22.000Z","updated":"2023-01-31T07:21:27.770Z","comments":true,"path":"2022/03/23/《Linux多线程服务端编程》阅读笔记/","link":"","permalink":"https://daidaini.github.io/2022/03/23/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E9%98%85%E8%AF%BB%E7%AC%94%E8%AE%B0/","excerpt":"","text":"1 当一个对象能被多个线程同时看到时，那么这个对象的销毁时机就会变得模糊不清，可能出现多种竞态条件： 在即将析构一个对象时，从何而知此刻是否有其他线程正在执行该对象的成员函数 如何保证在执行成员函数期间，对象不会在另一个线程被析构 在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？ 解决这些race condtion是C++多线程编程面临的基本问题。可以使用shared_ptr来一劳永逸地解决这些问题。 2 对象构造要做到线程安全，唯一的要求是构造期间不能泄漏this指针。 基于此，二段式构造–即构造函数 + initialize() – 有时会是好办法。这种方式虽然不符合C++教条，但是多线程下别无选择。 3 mutex不能安全地保护析构，因为一旦执行析构，mutex对象也会被销毁。这样，在多线程的情况下，如果其他线程正在使用mutex用到一半，就会有问题。 4 空悬指针： 两个指针p1，p2，指向堆里的同一个对象Object，并且p1和p2位于不同的线程中（线程A和线程B）。假设线程A通过p1指针将对象销毁了，那么p2就成了悬空指针。这是一种典型的C/C++内存错误。 要想安全地销毁对象，最好在别人(即别的线程)都看不到的情况下，偷偷地做。这个也正是垃圾回收(gc)的原理，所有人用不到的一定是垃圾。 （悬空指针，是指指向的内容已经被释放的指针） 5 C++里可能出现的内存问题大致有如下几个方面： 缓冲区溢出 (buffer overrun) 空悬指针 / 野指针 重复释放 (double delete) 内存泄漏 (memory leak) 不配对的 new[] / delete 内存碎片 (memory fragment) 而正确地使用智能指针可以很轻易地解决前5种问题 6 shared_ptr的拷贝开销要比原始指针的拷贝开销要高（因为拷贝的时候需要修改引用计数，而修改引用计数需要加锁操作）。所以，我们在将shared_ptr作为函数参数传递的时候，尽量使用常引用的形式，这样减少拷贝次数，来减少性能损失。 7 让this指针，能变身为shared_ptr的方法，是让类继承 enable_shared_from_this。 8 弱回调：如果对象还活着，就调用它的成员函数，否则忽略之。 9 read-copy-update 10 不推荐使用信用量(Semaphore)，原因： 条件变量配合互斥量可以完全替代其功能，而且更不易出错 semaphore has no notion of ownership 信号量有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存放了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。 如果要控制并发度，可以考虑用muduo::ThreadPool 11 使用 pthread_once 来实现 Singleton 12 在”non-blocing IO + IO multiplexing” 这种模型（即Reactor模式）中，程序的基本结构是一个事件循环(event loop)， 以事件驱动(event-driven) 和事件回调的方式实现业务逻辑。 Reactor摸型的优点： 编程不难，效率也不错。不仅可以用于读写socket，连接的建立，甚至DNS解析都可以用非阻塞的方式进行，以提高并发度和吞吐量，对于IO密集的应用是一个不错的选择。 缺点： 它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护。 13 one loop per thread libev的作者说： One loop per thread is usually a good model. Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start. 这种方式的好处，在于： 线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁 可以很方便地在线程之间调配负载 IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发 Eventloop代表了线程的主循环，需要让哪个线程干活，就把timer或IOchannel(如TCP连接)注册到哪个线程的loop里即可。 对实时性有要求的额connection 可以单独用一个线程； 数据量大的connection可以独占一个线程，并把数据处理任务分摊到另几个计算线程中（用线程池）； 其他次要的辅助性connection可以共享一个线程。 对于具有一定规模的服务端程序，一般就会采用 non-blockong + IO multiplexing， 每个connection/acceptor 都会注册到某个eventloop上，程序里有多个event loop,每个线程至多有一个event loop。 多线程程序对event loop 提出了更高的要求，那就是“线程安全”。要允许一个线程往别的线程的loop里塞数据，这个loop必须得是线程安全的。 14 进程间通信首选Sockets(主要是指TCP)，其最大的好处在于：可以跨主机，具有伸缩性。其他优势： 在编程上，TCP sockets和pipe都是操作文件描述符，用来收发字节流，都可以 read/write/fcntl/poll等。不同的是，TCP是双向的；Linux的pipe是单向的，使用没有TCP方便 TCP的port是由一个进程独占的，而且操作系会自动回收(listening port 和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会自动关闭所有文件描述符)。这说明，即使程序意外退出，也不会给系统留下垃圾，程序重启之后就可以比较容易地恢复，而不需要重启操作系统。还有一个好处，既然port是独占的，就可以防止程序重复启动。 两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接，另一个进程就会立刻感知到，可以快速failover（故障转移）。 与其他IPC相比，TCP的一个天生的好处是“可记录、可重现”。tcpdump和Wireshark 是解决两个进程间协议和状态争端的好帮手，也是性能(吞吐量、延迟等)分析的利器。我们可以借此编写分布式程序的自动化回归测试。还可以用tcpcopy之类的工具进行压力测试。 TCP还能跨语言，服务端和客户端之间可以不必使用同一种语言 使用TCP这种字节流方式通信，会有 marshal/unmarshal的开销，这就要求我们选用合适的消息格式，准确的说是 wire format(字节序列？)，推荐用 Google Protocol Buffers 15 使用TCP长连接的好处有两点： 容易定位分布式系统中的服务之间的依赖关系。只要在机器上运行 netstat -tpna | grep :port 就能立刻列出用到某服务的客户端地址，然后在客户端的机器上用 netstat 或者 lsof 命令找出是哪个进程发起的连接。 通过接收和发送队列的长度也比较容易定位网络或者程序故障。 16 本书对 “服务器开发” 的定义，用一句话形容： 跑在多核机器上的Linux用户态的没有用户界面的长期运行的 网络应用程序，通常是分布式系统的组成部件。 17 多线程的适用场景时：提高响应速度，让IO和“计算”相互重叠，降低latency(延迟)。虽然多线程不能提高绝对性能，但是能提高平均响应性能。 一个程序要做成多线程的，大致要满足： 有多个CPU可用。单核机器上多线程没有性能优势(但或许能简化并发业务逻辑的实现) 线程间有共享数据，即内存中的全局状态。 共享的数据是可以修改的，而不是静态常量表。 提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件。防止优先级反转。 latency 和 throuthput 同样重要，不是逻辑简单的 IO密集或是 CPU密集。换言之，程序是有相当的计算量的 能scale up(有规模的增长)。 一个好的多线程程序应该能享受增加CPU数目带来的好处，一旦CPU从8核升级到16核，程序能体现出这种升级带来的性能提升 具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点之后会极速下降。线程数目一般不随负载变化。 多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是所有逻辑塞到一个event loop中，导致不同类别的事件之间相互影响 18 多线程服务程序中的线程大致可以分为三类： IO线程，这类线程的主循环是IO multiplexing，阻塞地等在 select/poll/epoll_wait 等系统调用上。这类线程也处理定时事件。当然，它的功能不光光是IO，有些简单的计算也可以放入其中，比如消息的编码或者解码等。 计算线程，这类线程的主循环是 blocingqueue， 阻塞地等在 conditionvariable上。这类线程一般位于 thread pool中。这种线程一般不涉及IO，一般要避免任何阻塞操作 第三方库所用的线程，比如 logging ，又比如database connection等 19 Linux 能同时启动多少个线程？ 对于32-bit Linux，一个进程的地址空间是4GB，其中用户态能访问的为3GB左右，而一个线程的默认栈大小是10 MB，简单计算，一个进程大约可以同时启动300个线程。 对于64-bit系统，线程数目可大大增加 20 尽管C++03标准没有明说标准库的线程安全性，但 我们可以遵循一个基本原则：凡是非共享的对象都是彼此独立的，如果一个对象从始至终只被一个线程使用，那么它就是安全的。 另外一个事实标准是：共享的对象的read-only操作是安全的，前提是不能有并发的写操作。","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://daidaini.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"初始化列表","slug":"初始化列表","date":"2022-03-23T12:50:22.000Z","updated":"2023-01-30T03:01:06.806Z","comments":true,"path":"2022/03/23/初始化列表/","link":"","permalink":"https://daidaini.github.io/2022/03/23/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/","excerpt":"","text":"初始化列表的概念及使用C++98中，标准允许使用花括号”{}”对数组元素进行统一的集合初始值设定。比如： 12int arr[5] = &#123;0&#125;;int arr[] = &#123;1,2,3,4&#125;; C++11中，这种初始化的方法，被扩展到了集合（列表）中。 总结初始化方法如下：1） 等号加上赋值表达式，如 int a = 3+4；2） 等号 加上花括号的 初始化列表， 如 int a = {3+4};3） 圆括号式的表达式列表（expression list）, 如 int a = (3+4);4） 花括号式的初始化列表 ， 如 int a{3+4} 其中，第3、4中方式也可用于获取堆内存 new操作符中，如下： 12int * i = new int(5);double *d = new double(1.5f); 标准模板库中容器对初始化列表的支持源自这个头文件中initialize_list的类模板的支持。只需要包含这个头文件，并且声明一个以initialize_list模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。 利用初始化列表，重载operator[]，operator= 以及使用辅助的数组。例子如下： 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;iostream&gt;#include &lt;vector&gt;#include &lt;initializer_list&gt;using namespace std;class Mydata&#123;public: Mydata&amp; operator[](initializer_list&lt;int&gt; l)&#123; for(auto i=l.begin();i!=l.end();++i) idx.push_back(*i); return *this; &#125; Mydata&amp; operator=(int v)&#123; if(idx.empty()!=true) &#123; for(auto i = idx.begin();i!=idx.end();++i) &#123; d.resize((*i&gt;d.size())?*i:d.size()); d[*i-1] = v; &#125; idx.clear(); &#125; return *this; &#125; void print()&#123; for(auto i=d.begin();i!=d.end();++i) cout&lt;&lt;*i&lt;&lt;&quot; &quot;; cout&lt;&lt;endl; &#125;private: vector&lt;int&gt; idx; //辅助数组，用于记录index vector&lt;int&gt; d; &#125;;int main()&#123; Mydata d; d[&#123;2,3,5&#125;] = 7; //将第2，3，5位设为7 d[&#123;1,4,5,8&#125;] = 4; //第1，4，5，8位设为4 d.print(); //4 7 7 4 7 0 0 4&#125; 此外，初始化列表还可以用于函数返回的情况，但是返回一个初始化列表，通常会导致构造一个临时变量 123vector&lt;int&gt;Func()&#123; return &#123;1,3&#125;;&#125; 防止类型收窄使用列表初始化还有一个最大优势是 可以防止类型收窄。 类型收窄 一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。 可能导致 类型收窄的典型情况如下： 以浮点数隐式地转换为整型 比如： int a = 1.2 从高精度的浮点数转化为低精度的浮点数，比如： 从long double 隐式地转为 double。或者从double 转为 float。 这种精度降低，都可以视为类型收窄 从整型转为浮点数。如果整型数大到无法使用浮点数精确表达，也可以视为类型收窄 从整型，转为较低长度地整型。 比如：unsigned char = 1024; 1024是不能被8位地unsigned char 容纳的 使用初始化列表，是不能容许类型收窄的情况出现的。会编译通不过。 使用自定义初始化列表示例： 12345678910111213141516171819class Warriors&#123;public: Warriors(const initializer_list&lt;string&gt;&amp; members) &#123; for (auto&amp; data : members) &#123; players.emplace_back(data); &#125; &#125; vector&lt;string&gt; players; void print() &#123; for (auto itm : players) std::cout &lt;&lt; itm &lt;&lt; endl; &#125;&#125;;","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++特性","slug":"C-特性","permalink":"https://daidaini.github.io/tags/C-%E7%89%B9%E6%80%A7/"}]},{"title":"进程与线程","slug":"进程与线程","date":"2021-09-10T05:47:31.000Z","updated":"2023-01-31T07:25:30.806Z","comments":true,"path":"2021/09/10/进程与线程/","link":"","permalink":"https://daidaini.github.io/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"进程与线程的区别 当我们把代码编译链接生成后的可执行文件，装载到内存中进行运行，这个运行中的实例就是进程。 同一个可执行文件，可以有多个进程实例。而且，每个进程之间的内存资源都是相互独立、互不影响的。 换句话解释就是，进程是操作系统进行资源调度和内存分配的基本单位。 这些进程独享的资源，包括有代码、打开的文件、堆、栈、存放全局变量的数据段 以及一些内核内部使用的数据，比如运行状态等。 现代的操作系统都是会并发处理多任务的，所以必然会同时处理多个进程，那就必然需要进行进程的切换。而切换进程，意味着，需要将进程独占的那些资源都进行切换。 那由于进程管理的资源较多，相对切换的成本开销就较大了。这也是引入线程的概念的原因，线程是进程的一个子任务，是用来作为操作系统进行任务调度的最小单位。 首先线程是相对进程更轻量级的存在， 单个进程的线程间共享的资源包括： 代码段 全局数据段和静态数据段 栈区 理论上，栈区是属于线程是有的。 但是实际上，不同线程的栈区并没有严格的隔离机制来进行保护。 因此，如果一个线程拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说， 这些线程可以任意膝盖本属于另一个线程中的变量。 堆区 打开的文件描述符 命令行参数 信号处理函数 进程ID、进程组ID 线程独占的资源有：（即线程上下文） 线程的栈区 栈指针?(用来指向栈顶吗？) 程序计数器（一种寄存器） 函数运行使用的寄存器（保存部分局部变量之类） TLS(Thread Local Storage) 保存进程的信息的地方 称为PCB，进程控制块。 保存线程的信息的地方，就是TCB，线程控制块。 PCB存储的信息包括各种资源信息：内存地址空间信息、所有打开的文件、所有的I/O设备信息， 此外，还有进程描述符（即进程的标识，进程id），进程的运行状态，对应的用户描述符，各种寄存器的信息，以及进程的优先级（操作系统用来进行调度的算法需要）等信息。 TCB就相对少一点，除了线程描述符，也会记录对应的进程描述符，还有栈、寄存器等相关信息。 参考线程间到底共享了哪些进程资源 - 知乎 (zhihu.com)","categories":[{"name":"操作系统","slug":"操作系统","permalink":"https://daidaini.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"笔记","slug":"笔记","permalink":"https://daidaini.github.io/tags/%E7%AC%94%E8%AE%B0/"}]},{"title":"std::function的实验","slug":"函数模板function的实验","date":"2021-07-30T04:25:28.000Z","updated":"2023-01-30T03:00:07.407Z","comments":true,"path":"2021/07/30/函数模板function的实验/","link":"","permalink":"https://daidaini.github.io/2021/07/30/%E5%87%BD%E6%95%B0%E6%A8%A1%E6%9D%BFfunction%E7%9A%84%E5%AE%9E%E9%AA%8C/","excerpt":"","text":"std::function使用的几种形式 1234567891011121314151617181920212223242526272829303132inline namespace function_use&#123; int FuncB(int x, int y) &#123; return x + y; &#125; struct FuncC &#123; int operator()(int x, int y) &#123; return x + y; &#125; &#125;; void test_use_function() &#123; using funcType = std::function&lt;int(int, int)&gt;; funcType a = [](int x, int y) &#123; return x + y; &#125;; funcType b = FuncB; funcType c = FuncC(); cout &lt;&lt; &quot;a = &quot; &lt;&lt; a(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; b(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; c(30, 4) &lt;&lt; endl; &#125;&#125; 结果如下 a = 7b = 70c = 34 增加变化，加一个类如下 1234567891011121314151617181920212223class FuncContainer&#123;public: void Push(funcType&amp;&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp;&amp; func)\\n&quot;; m_contianer.emplace_back(std::forward&lt;funcType&gt;(func)); &#125; void Push(funcType&amp; func) &#123; cout &lt;&lt; &quot;using void Push(funcType&amp; func)\\n&quot;; m_contianer.emplace_back(func); &#125; funcType&amp; Take(int index) &#123; cout &lt;&lt; &quot;using funcType&amp; Take(int index)\\n&quot;; return m_contianer[index]; &#125;private: vector&lt;funcType&gt; m_contianer;&#125;; 测试方法如下 123456789101112131415void test_use_function()&#123; FuncContainer container; container.Push([](int x, int y) &#123; return x + y; &#125;); container.Push(FuncB); container.Push(FuncC()); auto afunc = container.Take(0); auto bfunc = container.Take(1); auto cfunc = container.Take(2); cout &lt;&lt; &quot;a = &quot; &lt;&lt; afunc(3, 4) &lt;&lt; endl; cout &lt;&lt; &quot;b = &quot; &lt;&lt; bfunc(30, 40) &lt;&lt; endl; cout &lt;&lt; &quot;c = &quot; &lt;&lt; cfunc(30, 4) &lt;&lt; endl;&#125; 测试结果 using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using void Push(funcType&amp;&amp; func)using funcType&amp; Take(int index)using funcType&amp; Take(int index)using funcType&amp; Take(int index)a = 7b = 70c = 34 实验结论 std::function 作为通用的多态函数封装器， std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针 std::function 配合using （或者typedef），可以用来作为容器的元素进行存储 std::function 作为函数参数传递时，都是作为右值引用来进行传递的 std::function 重载的 operator= 返回的是引用类型，所以，需要注意其存储元素的生命周期 参考: std::function - C++中文 - API参考文档 (apiref.com) http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++标准库","slug":"C-标准库","permalink":"https://daidaini.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"}]},{"title":"C++标准线程库的使用","slug":"C-11线程","date":"2021-07-30T01:59:29.000Z","updated":"2023-01-30T03:11:37.007Z","comments":true,"path":"2021/07/30/C-11线程/","link":"","permalink":"https://daidaini.github.io/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/","excerpt":"","text":"引子c++11后新增了线程库，最主要最熟知的应该就是 std::thread，以及配合以线程同步用的std::mutex和std::conditon_variable。 对于多核环境的高性能并发处理，后端开发最需要熟知的就是线程池。线程池本质上就是提前建立好多个线程，在需要使用的时候唤醒一个来处理，不需要的时候让其睡眠不占用资源。 以下先介绍标准线程库的一些使用方法，然后再依次实现下线程池。 使用std::thread库基本使用方式1234void ThreadFunc()&#123; //do something&#125;std::thread t(ThreadFunc); 如果是带参数的线程函数，就可以： 123456void ThreadFunc(int count)&#123; //do something&#125;std::thread t(ThreadFunc, 5);//或者 使用&lt;functional&gt;中提供的 std::bind方法，将参数绑定到对应的线程函数上std::thread t(std::bind(ThreadFunc, 5)); 关于线程的结束线程启动后，一般需要等到线程函数运行完，线程才能结束 标准库对于线程的结束也有两种方式： 1） 在主线程中调用join方法，主线程就会阻塞等待到线程函数运行完，然后结束 12if(t.joinable()) t.join() 2）调用detach方法，将线程从主线程分离。这种形式，主线程不会被阻塞，也不会知道分离出去的线程什么时候结束。 如果确定主线程肯定比线程函数晚结束，或者线程和主线程的存活时间是一致的，则可以直接在启动线程后，直接detach。 123t.detach();//简便的写法，声明和detach一起调用std::thread(ThreadFunc).detach(); std::thread启动线程的其他方式std::thread启动线程，也可以使用lambda表达式，参考如下： 1234567std::thread([]()&#123; for (int i = 0; i &lt; 20; ++i) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; static_cast&lt;char&gt;(&#x27;A&#x27; + i) &lt;&lt; endl; this_thread::sleep_for(10ms); &#125;&#125; ); 对于将参数为引用的函数来作为线程函数，也有如下两种操作可参考： 1） 使用lambda表达式，如下： 123456789101112131415unordered_map&lt;int, string&gt; myMapSrc&#123; &#123;1, &quot;first&quot; &#125;, &#123;2, &quot;second&quot;&#125;, &#123;3, &quot;third&quot;&#125;, &#123;4, &quot;four&quot;&#125;, &#123;5, &quot;five&quot;&#125; &#125;;//捕获列表使用 &amp; 就可以std::thread([&amp;myMapSrc]()&#123; for (const auto&amp; item : myMapSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125; ).detach(); 2） 使用std::bind，如下 12345678void ThreadFunc(unordered_map&lt;int, string&gt;&amp; refRec)&#123; for (const auto&amp; item : refSrc) &#123; cout &lt;&lt; &#x27;[&#x27; &lt;&lt; this_thread::get_id() &lt;&lt; &quot;]:&quot; &lt;&lt; item.first &lt;&lt; &quot; = &quot; &lt;&lt; item.second &lt;&lt; endl; &#125;&#125;std::thread(std::bind(ThreadFunc, std::ref(myMapSrc))); 由于std::bind总是使用值拷贝的形式传参，哪怕函数声明为引用，std::bind传递的时候也是值传递。所以，标准库提供了std::ref来给std::bind传引用。 std::async标准库，在std::thread的基础上，封装了一些方法，有std::promise，std::pacakged_task，以及std::async。 这其中，std::promise以及std::pacakged_task的使用，一般还是要配合std::thread以及std::future来。 这边，比较推荐使用std::async来启动一个线程来执行一个异步任务，简单的示例代码如下： 123std::async(launch::async, ThreadFunc);//带参数，则std::async(launch::async, ThreadFunc, param1, param2...); std::async 方法有返回值，类型是std::future 12345678910string ThreadFuncStr(int data)&#123; this_thread::sleep_for(1s); cout &lt;&lt; &quot;This is ThreadFuncStr\\n&quot;; return to_string(data);&#125;std::future&lt;string&gt; result = std::async(launch::async, ThreadFuncStr, 100);//do some other thing string str = result.get();cout &lt;&lt; str &lt;&lt;endl; 说明： std::async， 如果第一个参数是launch::async，那就是立即启动线程任务，但是线程启动后，不会阻塞当前线程。 只有在后续调用reuslt.get()的时候，会阻塞，直到线程函数返回需要的结果。 使用建议： 推荐std::async，是因为它将thread的概念隐藏到了底层，方法本身就成为了，我就是异步去执行一个任务。 所以，如果我们一旦碰到需要读写文件或者网络请求这种涉及IO，耗时不确定可能会阻塞当前运行线程的时候，都可以调用async，来启动一个异步任务完成这部分的业务处理。 另外： 如果想使用std::thread的形式，也需要获取线程函数执行后的返回值，可以使用packaged_task，简单举例： 1234567int main()&#123; std::packaged_task&lt;string(int)&gt; task(ThreadFuncStr); std::future&lt;string&gt; async_result = task.get_future(); std::thread(std::move(task), 100).detach(); cout &lt;&lt; async_result.get() &lt;&lt; endl; return 0;&#125; 感觉用起来，不如std::async方便，感兴趣的可以自行研究(报考std::promise 也是，它们都有各自的应用场景)。 线程池有执行一个异步任务来获取结果的需求，肯定也有不定时执行多个异步任务的需求。 最典型的就是，服务端处理多个不同用户的业务逻辑的场景： 1）每个用户的业务处理，一般都需要在自己独立的线程中运行； 2）线程处理完一个用户的业务逻辑，还可以处理另一个用户的业务逻辑。 这种情况，就比较适合用线程池了。 下边就是用C++11标准库实现的线程池的代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class FixedThreadPool&#123;public: using FuncTaskType = std::function&lt;void()&gt;; FixedThreadPool(size_t threadCount) : m_ResData(make_shared&lt;ResInfo&gt;()) &#123; for (size_t i = 0; i &lt; threadCount; ++i) &#123; std::thread(std::bind(&amp;FixedThreadPool::ThreadFunc, this)).detach(); &#125; &#125; ~FixedThreadPool() &#123; if (m_ResData != nullptr) &#123; std::lock_guard&lt;std::mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;IsShutdown = true; &#125; m_ResData-&gt;Cv.notify_all(); &#125; void Execute(FuncTaskType&amp;&amp; task) &#123; lock_guard&lt;mutex&gt; guard(m_ResData-&gt;Mtx); m_ResData-&gt;Tasks.emplace(std::forward&lt;FuncTaskType&gt;(task)); m_ResData-&gt;Cv.notify_one(); &#125;private: void ThreadFunc() &#123; unique_lock&lt;mutex&gt; lk(m_ResData-&gt;Mtx); do &#123; if (!m_ResData-&gt;Tasks.empty()) &#123; auto currentTask = std::move(m_ResData-&gt;Tasks.front()); m_ResData-&gt;Tasks.pop(); lk.unlock(); currentTask(); lk.lock(); &#125; else if (m_ResData-&gt;IsShutdown) &#123; break; &#125; else &#123; m_ResData-&gt;Cv.wait(lk); &#125; &#125; while (true); &#125; struct ResInfo &#123; mutex Mtx; condition_variable Cv; bool IsShutdown = false; //线程函数任务队列 queue&lt;FuncTaskType&gt; Tasks; &#125;; std::shared_ptr&lt;ResInfo&gt; m_ResData;&#125;; 简单解释： ResInfo 是需要的一些信息，包含线程同步用互斥量和条件变量，线程池的开关，以及存储线程任务的队列 ResInfo 使用 shared_ptr 是因为 每个线程都会进行一份拷贝 存储队列，使用queue，满足先进先出 线程任务，统一使用 函数模板 std::function&lt;void()&gt; ，这样，后续再配合std::bind，就可以执行所有带参数和不带参数的线程函数 构造的时候，直接启动对应数量的线程，每个线程的运行都封装在ThreadFunc ThreadFunc 使用unique_lock 一是需要配合条件变量进行wait， 二是，在将线程任务从队列中取出来之后，就不需要再锁了，可以unlock。 对于线程池内部的mutex，它用来保护的数据，其实就是线程任务队列，所以将线程任务从队列中取出来之后，这个锁的任务就达成了。 执行完线程任务，再锁住，是该线程在循环，执行完上一个任务，就会去队列中取下一个任务。 Execute方法，顾名思义，就是用来执行任务的。右值引用作为参数进行传递时，会转换成左值，需配合完美转发std::forward使用 最后，析构函数，主要是确保开关置为true，启动的线程函数可以正常运行结束。 参考: C++11 (三) - std::function、std::bind、std::ref C++11 std::thread detach()与join()用法总结","categories":[{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"}],"tags":[{"name":"C++标准库","slug":"C-标准库","permalink":"https://daidaini.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"}]}],"categories":[{"name":"C++11","slug":"C-11","permalink":"https://daidaini.github.io/categories/C-11/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://daidaini.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"C++编程","slug":"C-编程","permalink":"https://daidaini.github.io/categories/C-%E7%BC%96%E7%A8%8B/"},{"name":"操作系统","slug":"操作系统","permalink":"https://daidaini.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"}],"tags":[{"name":"C++学习","slug":"C-学习","permalink":"https://daidaini.github.io/tags/C-%E5%AD%A6%E4%B9%A0/"},{"name":"数据结构与算法","slug":"数据结构与算法","permalink":"https://daidaini.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"},{"name":"C语言","slug":"C语言","permalink":"https://daidaini.github.io/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"C++特性","slug":"C-特性","permalink":"https://daidaini.github.io/tags/C-%E7%89%B9%E6%80%A7/"},{"name":"笔记","slug":"笔记","permalink":"https://daidaini.github.io/tags/%E7%AC%94%E8%AE%B0/"},{"name":"C++标准库","slug":"C-标准库","permalink":"https://daidaini.github.io/tags/C-%E6%A0%87%E5%87%86%E5%BA%93/"}]}