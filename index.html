<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="C++编程学习">
<meta property="og:type" content="website">
<meta property="og:title" content="个人博客">
<meta property="og:url" content="http://example.com/index.html">
<meta property="og:site_name" content="个人博客">
<meta property="og:description" content="C++编程学习">
<meta property="og:locale" content="zn_CN">
<meta property="article:author" content="俞波">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="个人博客" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 5.4.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">个人博客</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">daidaini的学习空间</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main">
  
    <article id="post-《Linux多线程服务端编程》笔记" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/03/19/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/" class="article-date">
  <time class="dt-published" datetime="2022-03-19T05:35:24.857Z" itemprop="datePublished">2022-03-19</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>《Linux多线程服务端编程》</p>
<p>1 当一个对象能被多个线程同时看到时，那么这个对象的销毁时机就会变得模糊不清，可能出现多种竞态条件：</p>
<ul>
<li>在即将析构一个对象时，从何而知此刻是否有其他线程正在执行该对象的成员函数</li>
<li>如何保证在执行成员函数期间，对象不会在另一个线程被析构</li>
<li>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</li>
</ul>
<p>解决这些race condtion是C++多线程编程面临的基本问题。可以使用shared_ptr来一劳永逸地解决这些问题。</p>
<p>2 对象构造要做到线程安全，唯一的要求是构造期间不能泄漏this指针。</p>
<p>基于此，二段式构造–即构造函数 + initialize() – 有时会是好办法。这种方式虽然不符合C++教条，但是多线程下别无选择。</p>
<p>3 mutex不能安全地保护析构，因为一旦执行析构，mutex对象也会被销毁。这样，在多线程的情况下，如果其他线程正在使用mutex用到一半，就会有问题。</p>
<p>4 空悬指针：</p>
<p>两个指针p1，p2，指向堆里的同一个对象Object，并且p1和p2位于不同的线程中（线程A和线程B）。假设线程A通过p1指针将对象销毁了，那么p2就成了悬空指针。这是一种典型的C/C++内存错误。</p>
<p>要想安全地销毁对象，最好在别人(即别的线程)都看不到的情况下，偷偷地做。这个也正是垃圾回收(gc)的原理，所有人用不到的一定是垃圾。</p>
<p>（悬空指针，是指指向的内容已经被释放的指针）</p>
<p>5 C++里可能出现的内存问题大致有如下几个方面：</p>
<ul>
<li>缓冲区溢出 (buffer overrun)</li>
<li>空悬指针 / 野指针</li>
<li>重复释放 (double delete)</li>
<li>内存泄漏 (memory leak)</li>
<li>不配对的 new[] / delete</li>
<li>内存碎片 (memory fragment)</li>
</ul>
<p>而正确地使用智能指针可以很轻易地解决前5种问题</p>
<p>6 shared_ptr的拷贝开销要比原始指针的拷贝开销要高（因为拷贝的时候需要修改引用计数，而修改引用计数需要加锁操作）。所以，我们在将shared_ptr作为函数参数传递的时候，尽量使用常引用的形式，这样减少拷贝次数，来减少性能损失。</p>
<p>7 让this指针，能变身为shared_ptr的方法，是让类继承 enable_shared_from_this。</p>
<p>8 弱回调：如果对象还活着，就调用它的成员函数，否则忽略之。</p>
<p>9 read-copy-update</p>
<p>10 不推荐使用信用量(Semaphore)，原因：</p>
<ul>
<li>条件变量配合互斥量可以完全替代其功能，而且更不易出错</li>
<li>semaphore has no notion of ownership</li>
<li>信号量有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存放了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。</li>
<li>如果要控制并发度，可以考虑用muduo::ThreadPool</li>
</ul>
<p>11 使用 pthread_once 来实现 Singleton</p>
<p>12 在”non-blocing IO + IO multiplexing” 这种模型（即Reactor模式）中，程序的基本结构是一个事件循环(event loop)， 以事件驱动(event-driven) 和事件回调的方式实现业务逻辑。</p>
<p>Reactor摸型的优点：</p>
<p>编程不难，效率也不错。不仅可以用于读写socket，连接的建立，甚至DNS解析都可以用非阻塞的方式进行，以提高并发度和吞吐量，对于IO密集的应用是一个不错的选择。</p>
<p>缺点：</p>
<p>它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护。</p>
<p>13 one loop per thread</p>
<p>libev的作者说：</p>
<p>One loop per thread is usually a good model. Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start.</p>
<p>这种方式的好处，在于：</p>
<ul>
<li>线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁</li>
<li>可以很方便地在线程之间调配负载</li>
<li>IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发</li>
</ul>
<p>Eventloop代表了线程的主循环，需要让哪个线程干活，就把timer或IOchannel(如TCP连接)注册到哪个线程的loop里即可。</p>
<p>对实时性有要求的额connection 可以单独用一个线程；</p>
<p>数据量大的connection可以独占一个线程，并把数据处理任务分摊到另几个计算线程中（用线程池）；</p>
<p>其他次要的辅助性connection可以共享一个线程。</p>
<p>对于具有一定规模的服务端程序，一般就会采用 non-blockong + IO multiplexing， 每个connection/acceptor 都会注册到某个eventloop上，程序里有多个event loop,每个线程至多有一个event loop。</p>
<p>多线程程序对event loop 提出了更高的要求，那就是“线程安全”。要允许一个线程往别的线程的loop里塞数据，这个loop必须得是线程安全的。</p>
<p>14 进程间通信首选Sockets(主要是指TCP)，其最大的好处在于：可以跨主机，具有伸缩性。其他优势：</p>
<ul>
<li>在编程上，TCP sockets和pipe都是操作文件描述符，用来收发字节流，都可以 read/write/fcntl/poll等。不同的是，TCP是双向的；Linux的pipe是单向的，使用没有TCP方便</li>
<li>TCP的port是由一个进程独占的，而且操作系会自动回收(listening port 和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会自动关闭所有文件描述符)。这说明，即使程序意外退出，也不会给系统留下垃圾，程序重启之后就可以比较容易地恢复，而不需要重启操作系统。还有一个好处，既然port是独占的，就可以防止程序重复启动。</li>
<li>两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接，另一个进程就会立刻感知到，可以快速failover（故障转移）。</li>
<li>与其他IPC相比，TCP的一个天生的好处是“可记录、可重现”。tcpdump和Wireshark 是解决两个进程间协议和状态争端的好帮手，也是性能(吞吐量、延迟等)分析的利器。我们可以借此编写分布式程序的自动化回归测试。还可以用tcpcopy之类的工具进行压力测试。</li>
<li>TCP还能跨语言，服务端和客户端之间可以不必使用同一种语言</li>
<li>使用TCP这种字节流方式通信，会有 marshal/unmarshal的开销，这就要求我们选用合适的消息格式，准确的说是 wire format(字节序列？)，推荐用 Google Protocol Buffers</li>
</ul>
<p>15 使用TCP长连接的好处有两点：</p>
<ul>
<li>容易定位分布式系统中的服务之间的依赖关系。只要在机器上运行 netstat -tpna | grep :port 就能立刻列出用到某服务的客户端地址，然后在客户端的机器上用 netstat 或者 lsof 命令找出是哪个进程发起的连接。</li>
<li>通过接收和发送队列的长度也比较容易定位网络或者程序故障。</li>
</ul>
<p>16 本书对 “服务器开发” 的定义，用一句话形容：</p>
<p>跑在多核机器上的Linux用户态的没有用户界面的长期运行的 网络应用程序，通常是分布式系统的组成部件。</p>
<p>17 多线程的适用场景时：提高响应速度，让IO和“计算”相互重叠，降低latency(延迟)。虽然多线程不能提高绝对性能，但是能提高平均响应性能。</p>
<p>一个程序要做成多线程的，大致要满足：</p>
<ul>
<li>有多个CPU可用。单核机器上多线程没有性能优势(但或许能简化并发业务逻辑的实现)</li>
<li>线程间有共享数据，即内存中的全局状态。</li>
<li>共享的数据是可以修改的，而不是静态常量表。</li>
<li>提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件。防止优先级反转。</li>
<li>latency 和 throuthput 同样重要，不是逻辑简单的 IO密集或是 CPU密集。换言之，程序是有相当的计算量的</li>
<li>能scale up(有规模的增长)。 一个好的多线程程序应该能享受增加CPU数目带来的好处，一旦CPU从8核升级到16核，程序能体现出这种升级带来的性能提升</li>
<li>具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点之后会极速下降。线程数目一般不随负载变化。</li>
<li>多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是所有逻辑塞到一个event loop中，导致不同类别的事件之间相互影响</li>
</ul>
<p>18 多线程服务程序中的线程大致可以分为三类：</p>
<ul>
<li>IO线程，这类线程的主循环是IO multiplexing，阻塞地等在 select/poll/epoll_wait 等系统调用上。这类线程也处理定时事件。当然，它的功能不光光是IO，有些简单的计算也可以放入其中，比如消息的编码或者解码等。</li>
<li>计算线程，这类线程的主循环是 blocingqueue， 阻塞地等在 conditionvariable上。这类线程一般位于 thread pool中。这种线程一般不涉及IO，一般要避免任何阻塞操作</li>
<li>第三方库所用的线程，比如 logging ，又比如database connection等</li>
</ul>
<p>19 Linux 能同时启动多少个线程？</p>
<p>对于32-bit Linux，一个进程的地址空间是4GB，其中用户态能访问的为3GB左右，而一个线程的默认栈大小是10 MB，简单计算，一个进程大约可以同时启动300个线程。</p>
<p>对于64-bit系统，线程数目可大大增加</p>
<p>20 尽管C++03标准没有明说标准库的线程安全性，但</p>
<ul>
<li>我们可以遵循一个基本原则：凡是非共享的对象都是彼此独立的，如果一个对象从始至终只被一个线程使用，那么它就是安全的。</li>
<li>另外一个事实标准是：共享的对象的read-only操作是安全的，前提是不能有并发的写操作。</li>
</ul>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2022/03/19/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/" data-id="cl13k482h0008ywaxhoxw0eta" data-title="" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  
    <article id="post-进程与线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-09-10T05:47:31.000Z" itemprop="datePublished">2021-09-10</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-11/">C++11</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">进程与线程</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>进程与线程的区别</strong></p>
<p>当我们把代码编译链接生成后的可执行文件，装载到内存中进行运行，这个运行中的实例就是进程。</p>
<p>同一个可执行文件，可以有多个进程实例。而且，每个进程之间的内存资源都是相互独立、互不影响的。</p>
<p>换句话解释就是，进程是操作系统进行资源调度和内存分配的基本单位。</p>
<p>这些进程独享的资源，包括有代码、打开的文件、堆、栈、存放全局变量的数据段 以及一些内核内部使用的数据，比如运行状态等。</p>
<p>现代的操作系统都是会并发处理多任务的，所以必然会同时处理多个进程，那就必然需要进行进程的切换。而切换进程，意味着，需要将进程独占的那些资源都进行切换。</p>
<p>那由于进程管理的资源较多，相对切换的成本开销就较大了。这也是引入线程的概念的原因，线程是进程的一个子任务，是用来作为操作系统进行任务调度的最小单位。</p>
<p>首先线程是相对进程更轻量级的存在，</p>
<p>单个进程的线程间共享的资源包括：</p>
<ul>
<li>代码段</li>
<li>全局数据段和静态数据段</li>
<li>栈区</li>
</ul>
<p>理论上，栈区是属于线程是有的。</p>
<p>但是实际上，不同线程的栈区并没有严格的隔离机制来进行保护。</p>
<p>因此，如果一个线程拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说，</p>
<p>这些线程可以任意膝盖本属于另一个线程中的变量。</p>
<ul>
<li>堆区</li>
<li>打开的文件描述符</li>
<li>命令行参数</li>
<li>信号处理函数</li>
<li>进程ID、进程组ID</li>
</ul>
<p>线程独占的资源有：（即线程上下文）</p>
<ul>
<li>线程的栈区   栈指针?(用来指向栈顶吗？)</li>
<li>程序计数器（一种寄存器）</li>
<li>函数运行使用的寄存器（保存部分局部变量之类）</li>
<li>TLS(Thread Local Storage)</li>
</ul>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/352707156">线程间到底共享了哪些进程资源 - 知乎 (zhihu.com)</a></p>
<p>保存进程的信息的地方 称为PCB，进程控制块。</p>
<p>保存线程的信息的地方，就是TCB，线程控制块。</p>
<p>PCB存储的信息包括各种资源信息：内存地址空间信息、所有打开的文件、所有的I/O设备信息，</p>
<p>此外，还有进程描述符（即进程的标识，进程id），进程的运行状态，对应的用户描述符，各种寄存器的信息，以及进程的优先级（操作系统用来进行调度的算法需要）等信息。</p>
<p>TCB就相对少一点，除了线程描述符，也会记录对应的进程描述符，还有栈、寄存器等相关信息。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/" data-id="cl13k482i000aywax64gd4vvq" data-title="进程与线程" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-%E5%AD%A6%E4%B9%A0/" rel="tag">C++学习</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-std-function" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/30/std-function/" class="article-date">
  <time class="dt-published" datetime="2021-07-30T04:25:28.000Z" itemprop="datePublished">2021-07-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/30/std-function/">std-function</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><strong>std::function</strong></p>
<p>测试实验如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> test</span><br><span class="line">&#123;</span><br><span class="line">	<span class="function"><span class="keyword">int</span> <span class="title">FuncB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> x + y;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">FuncC</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		<span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			<span class="keyword">return</span> x + y;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">test_use_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="keyword">using</span> funcType = std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">		funcType a = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">			<span class="keyword">return</span> x + y;</span><br><span class="line">		&#125;;</span><br><span class="line"></span><br><span class="line">		funcType b = FuncB;</span><br><span class="line"></span><br><span class="line">		funcType c = <span class="built_in">FuncC</span>();</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; <span class="built_in">a</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; <span class="built_in">b</span>(<span class="number">30</span>, <span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; <span class="built_in">c</span>(<span class="number">30</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>结果如下：</p>
<p>a = 7<br>b = 70<br>c = 34</p>
<p>增加变化，加一个类如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuncContainer</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">	<span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(funcType&amp;&amp; func)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;using void Push(funcType&amp;&amp; func)\n&quot;</span>;</span><br><span class="line">			m_contianer.<span class="built_in">emplace_back</span>(std::forward&lt;funcType&gt;(func));</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(funcType&amp; func)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;using void Push(funcType&amp; func)\n&quot;</span>;</span><br><span class="line">			m_contianer.<span class="built_in">emplace_back</span>(func);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="function">funcType&amp; <span class="title">Take</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">		</span>&#123;</span><br><span class="line">			cout &lt;&lt; <span class="string">&quot;using funcType&amp; Take(int index)\n&quot;</span>;</span><br><span class="line">			<span class="keyword">return</span> m_contianer[index];</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">private</span>:</span><br><span class="line">		vector&lt;funcType&gt; m_contianer;</span><br><span class="line">	&#125;;</span><br></pre></td></tr></table></figure>



<p>测试方法如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_use_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		FuncContainer container;</span><br><span class="line">		container.<span class="built_in">Push</span>([](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line">			<span class="keyword">return</span> x + y;</span><br><span class="line">			&#125;);</span><br><span class="line">		container.<span class="built_in">Push</span>(FuncB);</span><br><span class="line">		container.<span class="built_in">Push</span>(<span class="built_in">FuncC</span>());</span><br><span class="line"></span><br><span class="line">		<span class="keyword">auto</span> afunc = container.<span class="built_in">Take</span>(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">auto</span> bfunc = container.<span class="built_in">Take</span>(<span class="number">1</span>);</span><br><span class="line">		<span class="keyword">auto</span> cfunc = container.<span class="built_in">Take</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; <span class="built_in">afunc</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; <span class="built_in">bfunc</span>(<span class="number">30</span>, <span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; <span class="built_in">cfunc</span>(<span class="number">30</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>测试结果：</p>
<p>using void Push(funcType&amp;&amp; func)<br>using void Push(funcType&amp;&amp; func)<br>using void Push(funcType&amp;&amp; func)<br>using funcType&amp; Take(int index)<br>using funcType&amp; Take(int index)<br>using funcType&amp; Take(int index)<br>a = 7<br>b = 70<br>c = 34</p>
<p>实验结论：</p>
<ol>
<li> std::function 作为通用的多态函数封装器， std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针</li>
<li> std::function 配合using （或者typedef），可以用来作为容器的元素进行存储</li>
<li> std::function 作为函数参数传递时，都是作为右值引用来进行传递的</li>
<li> std::function 重载的 operator= 返回的是引用类型，所以，需要注意其存储元素的生命周期</li>
</ol>
<p>参考：</p>
<p><a target="_blank" rel="noopener" href="https://www.apiref.com/cpp-zh/cpp/utility/functional/function.html">std::function - C++中文 - API参考文档 (apiref.com)</a></p>
<p><a target="_blank" rel="noopener" href="http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E">http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/30/std-function/" data-id="cl13k482h0007ywaxaewsfdnt" data-title="std-function" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-C-11线程" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/" class="article-date">
  <time class="dt-published" datetime="2021-07-30T01:59:29.000Z" itemprop="datePublished">2021-07-30</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/">C++11线程库使用</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="c-11线程"><a href="#c-11线程" class="headerlink" title="c++11线程"></a>c++11线程</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>关于线程池，之前交易网关这边虽然会管理多个线程，但一直没有用到线程池去管理。</p>
<p>前段时间，给国密的mauth服务器做一个校验账号密码的通讯组件的时候，使用了一个线程处理一个用户的校验的设计，所以尝试着去使用了线程池，</p>
<p>并且，他们的程序是运行在linux系统的，所以线程池也首次使用了c++11的方法去实现</p>
<p>c++11新增了线程库，最主要最熟知的应该就是 std::thread，以及配合以线程同步用的std::mutex和std::conditon_variable。</p>
<p>有了以上三个特性，我们可以很简便的实现一个跨线程的任务队列(BlockingQueue)，这个是实现线程池的基础。</p>
<p>所以，今天主要先分享下 c++11 线程库使用的一些方法，然后再分享下c++11的线程池实现。</p>
<h4 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h4><h5 id="使用thread库"><a href="#使用thread库" class="headerlink" title="使用thread库"></a>使用thread库</h5><p>最常见的启动一个线程的方法：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(ThreadFunc)</span></span>;</span><br></pre></td></tr></table></figure>

<p>如果是带参数的线程函数，就可以：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(ThreadFunc, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">//或者 使用&lt;functional&gt;中提供的 std::bind方法，将参数绑定到对应的线程函数上</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::bind(ThreadFunc, <span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure>

<p>交易网关这边，基于std::thread实现了一个ThreadBase的类，来封装线程的启动和停止，可以参考。</p>
<h5 id="关于线程的结束"><a href="#关于线程的结束" class="headerlink" title="关于线程的结束"></a>关于线程的结束</h5><p>线程启动后，一般需要等到线程函数运行完，线程才能结束</p>
<p>标准库对于线程的结束也有两种方式：</p>
<p>1） 在主线程中调用join方法，主线程就会阻塞等待到线程函数运行完，然后结束</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">    t.<span class="built_in">join</span>()</span><br></pre></td></tr></table></figure>

<p>2）调用detach方法，将线程从主线程分离。这种形式，主线程不会被阻塞，也不会知道分离出去的线程什么时候结束。</p>
<p>如果确定主线程肯定比线程函数晚结束，或者线程和主线程的存活时间是一致的，则可以直接在启动线程后，直接detach。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"><span class="comment">//简便的写法，声明和detach一起调用</span></span><br><span class="line">std::<span class="built_in">thread</span>(ThreadFunc).<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>

<h5 id="thread启动线程的其他方式"><a href="#thread启动线程的其他方式" class="headerlink" title="thread启动线程的其他方式"></a>thread启动线程的其他方式</h5><p>此外，std::thread启动线程，也可以使用lambda表达式，参考如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">thread</span>([]()&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;A&#x27;</span> + i) &lt;&lt; endl;</span><br><span class="line">				this_thread::<span class="built_in">sleep_for</span>(<span class="number">10</span>ms);</span><br><span class="line">			&#125;&#125;</span><br><span class="line">           );</span><br></pre></td></tr></table></figure>



<p>对于将参数为引用的函数来作为线程函数，也有如下两种操作可参考：</p>
<p>1） 使用lambda表达式，如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, string&gt; myMapSrc&#123;</span><br><span class="line">	&#123;<span class="number">1</span>, <span class="string">&quot;first&quot;</span> &#125;,</span><br><span class="line">	&#123;<span class="number">2</span>, <span class="string">&quot;second&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="number">3</span>, <span class="string">&quot;third&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="number">4</span>, <span class="string">&quot;four&quot;</span>&#125;,</span><br><span class="line">	&#123;<span class="number">5</span>, <span class="string">&quot;five&quot;</span>&#125;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获列表使用 &amp; 就可以</span></span><br><span class="line">std::<span class="built_in">thread</span>([&amp;myMapSrc]()&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : myMapSrc)</span><br><span class="line">			&#123;</span><br><span class="line">				cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; item.first &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">			&#125;&#125;</span><br><span class="line">	).<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure>

<p>2） 使用std::bind，如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(unordered_map&lt;<span class="keyword">int</span>, string&gt;&amp; refRec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : refSrc)</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; item.first &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(ThreadFunc, std::<span class="built_in">ref</span>(myMapSrc)));</span><br></pre></td></tr></table></figure>

<p>由于std::bind总是使用值拷贝的形式传参，哪怕函数声明为引用，std::bind传递的时候也是值传递。所以，标准库提供了std::ref来给std::bind传引用。</p>
<h4 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h4><p>标准库，在std::thread的基础上，封装了一些方法，有std::promise，std::pacakged_task，以及std::async。</p>
<p>这其中，std::promise以及std::pacakged_task的使用，一般还是要配合std::thread以及std::future来。</p>
<p>这边，比较推荐使用std::async来启动一个线程来执行一个异步任务，简单的示例代码如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">async</span>(launch::async, ThreadFunc);</span><br><span class="line"><span class="comment">//带参数，则</span></span><br><span class="line">std::<span class="built_in">async</span>(launch::async, ThreadFunc, param1, param2...);</span><br></pre></td></tr></table></figure>

<p>std::async 方法有返回值，类型是std::future<T></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ThreadFuncStr</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;This is ThreadFuncStr\n&quot;</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">to_string</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">std::future&lt;string&gt; result = std::<span class="built_in">async</span>(launch::async, ThreadFuncStr, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//do some other thing </span></span><br><span class="line">string str = result.<span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; str &lt;&lt;endl;</span><br></pre></td></tr></table></figure>

<p>说明：</p>
<p>std::async， 如果第一个参数是launch::async，那就是立即启动线程任务，但是线程启动后，不会阻塞当前线程。</p>
<p>只有在后续调用reuslt.get()的时候，会阻塞，直到线程函数返回需要的结果。</p>
<p>使用建议：</p>
<p>推荐std::async，是因为它将thread的概念隐藏到了底层，方法本身就成为了，我就是异步去执行一个任务。</p>
<p>所以，如果我们一旦碰到需要读写文件或者网络请求这种涉及IO，耗时不确定可能会阻塞当前运行线程的时候，都可以调用async，来启动一个异步任务完成这部分的业务处理。</p>
<p>另外：</p>
<p>如果想使用std::thread的形式，也需要获取线程函数执行后的返回值，可以使用packaged_task，简单举例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">string</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(ThreadFuncStr)</span></span>;	</span><br><span class="line">    std::future&lt;string&gt; async_result = task.<span class="built_in">get_future</span>();	</span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task), <span class="number">100</span>).<span class="built_in">detach</span>();	</span><br><span class="line">    cout &lt;&lt; async_result.<span class="built_in">get</span>() &lt;&lt; endl;  	</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>感觉用起来，不如std::async方便，感兴趣的可以自行研究(报考std::promise 也是，它们都有各自的应用场景)。</p>
<h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>有执行一个异步任务来获取结果的需求，肯定也有不定时执行多个异步任务的需求。</p>
<p>最典型的就是，服务端处理多个不同用户的业务逻辑的场景：</p>
<p>1）每个用户的业务处理，一般都需要在自己独立的线程中运行；</p>
<p>2）线程处理完一个用户的业务逻辑，还可以处理另一个用户的业务逻辑。</p>
<p>这种情况，就比较适合用线程池了。</p>
<p>下边就是用C++11标准库实现的线程池的代码：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="keyword">using</span> FuncTaskType = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line"></span><br><span class="line">	<span class="built_in">FixedThreadPool</span>(<span class="keyword">size_t</span> threadCount) :</span><br><span class="line">		<span class="built_in">m_ResData</span>(make_shared&lt;ResInfo&gt;())</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; ++i)</span><br><span class="line">		&#123;</span><br><span class="line">			std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;FixedThreadPool::ThreadFunc, <span class="keyword">this</span>)).<span class="built_in">detach</span>();</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	~<span class="built_in">FixedThreadPool</span>()</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">if</span> (m_ResData != <span class="literal">nullptr</span>)</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_ResData-&gt;Mtx)</span></span>;</span><br><span class="line">			m_ResData-&gt;IsShutdown = <span class="literal">true</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		m_ResData-&gt;Cv.<span class="built_in">notify_all</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">(FuncTaskType&amp;&amp; task)</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m_ResData-&gt;Mtx)</span></span>;</span><br><span class="line">		m_ResData-&gt;Tasks.<span class="built_in">emplace</span>(std::forward&lt;FuncTaskType&gt;(task));</span><br><span class="line">		m_ResData-&gt;Cv.<span class="built_in">notify_one</span>();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function">	</span>&#123;</span><br><span class="line">		<span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(m_ResData-&gt;Mtx)</span></span>;</span><br><span class="line">		<span class="keyword">do</span></span><br><span class="line">		&#123;</span><br><span class="line">			<span class="keyword">if</span> (!m_ResData-&gt;Tasks.<span class="built_in">empty</span>())</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">auto</span> currentTask = std::<span class="built_in">move</span>(m_ResData-&gt;Tasks.<span class="built_in">front</span>());</span><br><span class="line">				m_ResData-&gt;Tasks.<span class="built_in">pop</span>();</span><br><span class="line">				lk.<span class="built_in">unlock</span>();</span><br><span class="line">				<span class="built_in">currentTask</span>();</span><br><span class="line">				lk.<span class="built_in">lock</span>();</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span> <span class="keyword">if</span> (m_ResData-&gt;IsShutdown)</span><br><span class="line">			&#123;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="keyword">else</span></span><br><span class="line">			&#123;</span><br><span class="line">				m_ResData-&gt;Cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ResInfo</span></span></span><br><span class="line"><span class="class">	&#123;</span></span><br><span class="line">		mutex Mtx;</span><br><span class="line">		condition_variable Cv;</span><br><span class="line">		<span class="keyword">bool</span> IsShutdown = <span class="literal">false</span>;</span><br><span class="line">		<span class="comment">//线程函数任务队列</span></span><br><span class="line">		queue&lt;FuncTaskType&gt; Tasks;</span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	std::shared_ptr&lt;ResInfo&gt; m_ResData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>简单解释：</p>
<ul>
<li><p>ResInfo 是需要的一些信息，包含线程同步用互斥量和条件变量，线程池的开关，以及存储线程任务的队列</p>
</li>
<li><p>ResInfo 使用 shared_ptr 是因为 每个线程都会进行一份拷贝</p>
</li>
<li><p>存储队列，使用queue，满足先进先出</p>
</li>
<li><p>线程任务，统一使用 函数模板 std::function&lt;void()&gt; ，这样，后续再配合std::bind，就可以执行所有带参数和不带参数的线程函数</p>
</li>
<li><p>构造的时候，直接启动对应数量的线程，每个线程的运行都封装在ThreadFunc</p>
</li>
<li><p>ThreadFunc 使用unique_lock 一是需要配合条件变量进行wait，</p>
<p>二是，在将线程任务从队列中取出来之后，就不需要再锁了，可以unlock。</p>
<p>对于线程池内部的mutex，它用来保护的数据，其实就是线程任务队列，所以将线程任务从队列中取出来之后，这个锁的任务就达成了。</p>
<p>执行完线程任务，再锁住，是该线程在循环，执行完上一个任务，就会去队列中取下一个任务。</p>
</li>
<li><p>Execute方法，顾名思义，就是用来执行任务的。右值引用作为参数进行传递时，会转换成左值，需配合完美转发std::forward使用</p>
</li>
<li><p>最后，析构函数，主要是确保开关置为true，启动的线程函数可以正常运行结束。</p>
</li>
</ul>
<p>参考:</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/chenwh_cn/article/details/116492680">C++11 (三) - std::function、std::bind、std::ref</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_44862644/article/details/115765250">C++11 std::thread detach()与join()用法总结</a></p>
<p>《Linux多线程服务端编程》</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/" data-id="cl13k482a0001ywax9jpkcn5l" data-title="C++11线程库使用" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li></ul>

    </footer>
  </div>
  
</article>



  
    <article id="post-hello-world" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/07/30/hello-world/" class="article-date">
  <time class="dt-published" datetime="2021-07-30T01:53:10.230Z" itemprop="datePublished">2021-07-30</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="p-name article-title" href="/2021/07/30/hello-world/">Hello World</a>
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p>Welcome to <a target="_blank" rel="noopener" href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a target="_blank" rel="noopener" href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a target="_blank" rel="noopener" href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a target="_blank" rel="noopener" href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a target="_blank" rel="noopener" href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/07/30/hello-world/" data-id="cl13k482c0002ywaxd784dzy4" data-title="Hello World" class="article-share-link">Share</a>
      
      
      
    </footer>
  </div>
  
</article>



  


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/C-11/">C++11</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/C-%E7%BC%96%E7%A8%8B/">C++编程</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-11/" rel="tag">C++11</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C-%E5%AD%A6%E4%B9%A0/" rel="tag">C++学习</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/C-11/" style="font-size: 20px;">C++11</a> <a href="/tags/C-%E5%AD%A6%E4%B9%A0/" style="font-size: 10px;">C++学习</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">September 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/07/">July 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/19/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/">(no title)</a>
          </li>
        
          <li>
            <a href="/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/">进程与线程</a>
          </li>
        
          <li>
            <a href="/2021/07/30/std-function/">std-function</a>
          </li>
        
          <li>
            <a href="/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/">C++11线程库使用</a>
          </li>
        
          <li>
            <a href="/2021/07/30/hello-world/">Hello World</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 俞波<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>