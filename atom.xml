<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>个人博客</title>
  
  <subtitle>daidaini的学习空间</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-03-23T13:48:50.951Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>俞波</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>常用Linux命令</title>
    <link href="http://example.com/2022/03/23/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/"/>
    <id>http://example.com/2022/03/23/%E5%B8%B8%E7%94%A8Linux%E5%91%BD%E4%BB%A4/</id>
    <published>2022-03-23T13:14:28.000Z</published>
    <updated>2022-03-23T13:48:50.951Z</updated>
    
    <content type="html"><![CDATA[<h3 id="修改文件操作权限"><a href="#修改文件操作权限" class="headerlink" title="修改文件操作权限"></a>修改文件操作权限</h3><p><strong>命令为 chmod， 有两种操作方式</strong>，</p><p>一种为普通授权法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x a.txt  #给a.txt可执行的权限</span><br><span class="line">chmod +r a.txt  #给a.txt可读的权限</span><br></pre></td></tr></table></figure><p>文件权限，’r’ 代表可读(4)，’w’代表可写(2)， ‘x’代表可执行(1)</p><p>上面括号内的数字 代表 “8421法”，即第二种操作方式。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod 777 a.txt  #表示给a.txt所有权限</span><br></pre></td></tr></table></figure><p>关于文件的权限信息说明：</p><blockquote><p>-r-xr-xr-x 1 yubo yubo 342 May 27 22:06 hello.sh*</p></blockquote><p>前面的 “-r-xr-xr-x” 即对应文件的权限信息。</p><p>其中，第一位是’-‘ 这个表示文件， 如果是’d’就表示文件夹；</p><p>后面分为三组，分别表示 “拥有者的权限”，“拥有者所在的组、组员的权限”，“其他用户的权限”；</p><p>每一组的权限，都是三位，分别代表 读写和执行的权限，所以，如果三个权限都有，就稳定为 “rwx”。</p><p>对上述文件，修改，使文件所有者有 所有权限：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chmod 755 hello.sh</span><br><span class="line">$ll</span><br><span class="line">$-rwxr-xr-x 1 yubo yubo  342 May 27 22:06 hello.sh*</span><br></pre></td></tr></table></figure><h3 id="编辑文件"><a href="#编辑文件" class="headerlink" title="编辑文件"></a>编辑文件</h3><p><strong>命令: vi 和 vim</strong></p><p>操作： vi + 文件名</p><p>进入后，操作界面有三种模式：命令模式、插入模式和底行模式</p><p>三种模式相关定义：</p><blockquote><h5 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h5><ul><li><p>刚进入文件就是命令模式，通过方向键控制光标位置，</p></li><li><p>使用命令”dd”删除当前整行</p></li><li><p>使用命令”/字段”进行查找</p></li><li><p>按”i”在光标所在字符前开始插入</p></li><li><p>按”a”在光标所在字符后开始插入</p></li><li><p>按”o”在光标所在行的下面另起一新行插入</p></li><li><p>按”：”进入底行模式</p></li></ul><h5 id="插入模式"><a href="#插入模式" class="headerlink" title="插入模式"></a><strong>插入模式</strong></h5><ul><li><p>此时可以对文件内容进行编辑，左下角会显示 “– 插入 –””</p></li><li><p>按”ESC”进入底行模式</p></li><li><p>底行模式</p></li><li><p>退出编辑： :q</p></li><li><p>强制退出： :q!</p></li><li><p>保存并退出： :wq</p></li></ul><h5 id="操作步骤示例"><a href="#操作步骤示例" class="headerlink" title="操作步骤示例"></a><strong>操作步骤示例</strong></h5><ol><li><p>保存文件：按”ESC” -&gt; 输入”:” -&gt; 输入”wq”,回车 //保存并退出编辑</p></li><li><p>取消操作：按”ESC” -&gt; 输入”:” -&gt; 输入”q!”,回车 //撤销本次修改并退出编辑</p></li></ol><h5 id="补充"><a href="#补充" class="headerlink" title="补充"></a><strong>补充</strong></h5><ul><li><p>vim +10 filename.txt //打开文件并跳到第10行</p></li><li><p>vim -R /etc/passwd //以只读模式打开文件</p></li></ul></blockquote><h3 id="其他操作"><a href="#其他操作" class="headerlink" title="其他操作"></a>其他操作</h3><h4 id="find"><a href="#find" class="headerlink" title="find"></a>find</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">find /bin -name &#x27;a*&#x27; </span><br><span class="line">//查找bin目录下所有以a开头的文件或者目录</span><br><span class="line"></span><br><span class="line">find . -name &#x27;*.c&#x27; </span><br><span class="line">//将当前目录及其子目录下，所有.c文件找出来</span><br><span class="line"></span><br><span class="line">find . -type f</span><br><span class="line">//将当前目录及其子目录下的所有一般文件列出</span><br><span class="line"></span><br><span class="line">find . -ctime -20</span><br><span class="line">//将当前目录及其子目录下 所有最近20天更新过的文件列出</span><br><span class="line"></span><br><span class="line">find . -type f -perm 664 -exec ls -l &#123;&#125; \;</span><br><span class="line">//将当前目录及其子目录下， 所有权限为664的文件，列出</span><br><span class="line">//解释：这个命令可以分为两部分看，前半部分，到 -perm 664表示是查看文件的信息的权限；</span><br><span class="line">//后半部分，表示从执行ls -l 命令获取到的信息中进行筛选。</span><br></pre></td></tr></table></figure><h4 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">whereis ls</span><br><span class="line">#将和ls命令相关的文件都找出来  参数是某个命令（验证过 cmake ssh等）</span><br></pre></td></tr></table></figure><h4 id="which"><a href="#which" class="headerlink" title="which"></a>which</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#which指令 会在环境变量 $PATH 设置的目录里查找符合条件的文件</span><br><span class="line">which is bash</span><br></pre></td></tr></table></figure><h4 id="sudo"><a href="#sudo" class="headerlink" title="sudo"></a>sudo</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#sudo 命令 以系统管理者的身份执行，也就是说，经由sudo执行的命令就好像 是 root亲自执行。</span><br><span class="line">#需要输入自己的账户密码。</span><br><span class="line">#使用权限: 在 /etc/sudoers 中出现的使用者</span><br><span class="line">$ sudo -u yao vi ~www/index.html  #以yao用户身份编辑 home目录下的index.html文件</span><br></pre></td></tr></table></figure><h4 id="环境变量"><a href="#环境变量" class="headerlink" title="环境变量"></a>环境变量</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//查看当前环境变量</span><br><span class="line">echo $PATH</span><br><span class="line"></span><br><span class="line">//设置环境变量值</span><br><span class="line">export PATH=</span><br><span class="line"></span><br><span class="line">//添加一个路径</span><br><span class="line">export PATH=$PATH:newdir</span><br></pre></td></tr></table></figure><h4 id="查看操作系统版本信息"><a href="#查看操作系统版本信息" class="headerlink" title="查看操作系统版本信息"></a>查看操作系统版本信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/version</span><br></pre></td></tr></table></figure><h4 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">uname -a</span><br><span class="line">//显示一些重要的系统信息，例如：内核名称、主机名、内核版本号、处理器类型之类信息</span><br></pre></td></tr></table></figure><h4 id="设置系统时间"><a href="#设置系统时间" class="headerlink" title="设置系统时间"></a>设置系统时间</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date -s &quot;06/31/2021 16:59:50&quot;</span><br></pre></td></tr></table></figure><p>    </p><h3 id="文件查询搜索命令"><a href="#文件查询搜索命令" class="headerlink" title="文件查询搜索命令"></a>文件查询搜索命令</h3><h4 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] [文件]</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#在文件中查找字符串（不区分大小写）</span><br><span class="line">grep -i &quot;the&quot; demo_file  </span><br><span class="line"></span><br><span class="line">#在一个文件夹中递归查询包括指定字符串的文件</span><br><span class="line">grep -r &quot;remesh&quot; *  </span><br></pre></td></tr></table></figure><table><thead><tr><th>参数</th><th>作用</th></tr></thead><tbody><tr><td>-b</td><td>将可执行文件(binary) 当作文本文件(txt)来搜索</td></tr><tr><td>-c</td><td>仅显示查找到的次数</td></tr><tr><td>-i</td><td>忽略大小写</td></tr><tr><td>-n</td><td>显示行号</td></tr><tr><td>-v</td><td>反向选择–仅列出没有“关键词”的行</td></tr></tbody></table><h4 id="service"><a href="#service" class="headerlink" title="service"></a>service</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#service命令用于运行System V init脚本，这些脚本一般位于/etc/init.d 文件中</span><br><span class="line">#该命令可以直接运行脚本，而不需要加上路径</span><br><span class="line">service ssh status  #查看服务状态</span><br><span class="line">service --status-all  #查看所有服务状态</span><br><span class="line">service ssh restart  #重启服务</span><br></pre></td></tr></table></figure><h4 id="free"><a href="#free" class="headerlink" title="free"></a>free</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#这个命令用于显示系统当前内存的使用情况，包括已用内存、可用内存和交换内存的情况</span><br><span class="line">free -g #以g为单位输出内存的使用量，-g为GB，-m为MB，-k为KB，-b为字节</span><br><span class="line">free -t #查看所有内存的汇总</span><br></pre></td></tr></table></figure><h4 id="top"><a href="#top" class="headerlink" title="top"></a>top</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">显示当前系统中占用资源最多的一些进程，shift+m 按照内存大小进行排序</span><br></pre></td></tr></table></figure><h4 id="df"><a href="#df" class="headerlink" title="df"></a>df</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#显示文件系统的磁盘使用情况</span><br><span class="line">df -h  //一种易看的显</span><br></pre></td></tr></table></figure><h4 id="wget"><a href="#wget" class="headerlink" title="wget"></a>wget</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//该命令用于从网上下载内容</span><br><span class="line">wget http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz</span><br><span class="line"></span><br><span class="line">//下载文件并以指定的文件名保存文件</span><br><span class="line">wget -O nagios.tar.gz http://prdownloads.sourceforge.net/sourceforge/nagios/nagios-3.2.1.tar.gz</span><br></pre></td></tr></table></figure><h4 id="ftp"><a href="#ftp" class="headerlink" title="ftp"></a>ftp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ftp IP/hostname //访问ftp服务器</span><br><span class="line">mls *.html - //显示远程主机上文件列表</span><br></pre></td></tr></table></figure><h4 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">scp /opt/data.txt  192.168.1.101:/opt/    </span><br><span class="line">//将本地opt目录下的data文件发送到192.168.1.101服务器的opt目录下</span><br></pre></td></tr></table></figure><h3 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h3><h4 id="防火墙操作"><a href="#防火墙操作" class="headerlink" title="防火墙操作"></a>防火墙操作</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service iptables status      //查看iptables服务的状态</span><br><span class="line">service iptables start       //开启iptables服务</span><br><span class="line">service iptables stop        //停止iptables服务</span><br><span class="line">service iptables restart     //重启iptables服务</span><br><span class="line">chkconfig iptables off       //关闭iptables服务的开机自启动</span><br><span class="line">chkconfig iptables on        //开启iptables服务的开机自启动</span><br></pre></td></tr></table></figure><h4 id="查看网络"><a href="#查看网络" class="headerlink" title="查看网络"></a>查看网络</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ifconfig</span><br><span class="line"></span><br><span class="line">ping IP  //查看与IP的连接情况</span><br><span class="line"></span><br><span class="line">netstat -an  //查看当前系统端口</span><br><span class="line">netstat -an | grep 8080  //查看指定端口</span><br><span class="line"></span><br><span class="line">ssh IP  //远程主机，需要输入用户名密码</span><br></pre></td></tr></table></figure><h4 id="修改IP"><a href="#修改IP" class="headerlink" title="修改IP"></a>修改IP</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">修改网络配置文件，文件地址：/etc/sysconfig/network-scripts/ifcfg-eth0</span><br></pre></td></tr></table></figure><p>主要对应以下配置：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">TYPE=Ethernet               //网络类型</span><br><span class="line">  BOOTPROTO=static            //静态IP</span><br><span class="line">  DEVICE=ens00                //网卡名</span><br><span class="line">  IPADDR=192.168.1.100        //设置的IP</span><br><span class="line">  NETMASK=255.255.255.0       //子网掩码</span><br><span class="line">  GATEWAY=192.168.1.1         //网关</span><br><span class="line">  DNS1=192.168.1.1            //DNS</span><br><span class="line">  DNS2=8.8.8.8                //备用DNS</span><br><span class="line">  ONBOOT=yes                  //系统启动时启动此设置</span><br></pre></td></tr></table></figure><p>修改以后，使用命令重启网卡</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service network restart</span><br></pre></td></tr></table></figure><h4 id="配置映射"><a href="#配置映射" class="headerlink" title="配置映射"></a>配置映射</h4><blockquote><p>修改文件: vi /etc/hosts<br> 在文件最后添加映射地址，示例如下：<br> 192.168.1.101 node1<br> 192.168.1.102 node2<br> 192.168.1.103 node3<br> 配置好以后保存退出，输入命令：ping node1 ，可见实际 ping 的是 192.168.1.101。</p></blockquote><p>       </p><h4 id="进程信息"><a href="#进程信息" class="headerlink" title="进程信息"></a>进程信息</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ps -ef //查看所有正在运行的进程</span><br><span class="line">kill pid //杀死pid进程</span><br><span class="line">kill -9 pid  //强制杀死该进程</span><br></pre></td></tr></table></figure><h3 id="创建新用户"><a href="#创建新用户" class="headerlink" title="创建新用户"></a>创建新用户</h3><p>root权限下，使用 useradd 命令进行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">useradd -m daidaini -c &quot;test creating a new user&quot;</span><br></pre></td></tr></table></figure><p>指定密码，使用：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">passwd daidaini ***</span><br></pre></td></tr></table></figure><h3 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">//创建文件</span><br><span class="line">touch a.txt</span><br><span class="line">//移动文件</span><br><span class="line">mv [选项] 文件名 [目标文件名|目标路径]</span><br><span class="line">//复制文件</span><br><span class="line">cp [选项] 源文件 目标文件</span><br><span class="line">//复制文件夹</span><br><span class="line">cp -r dir1 dir2</span><br><span class="line">//删文件 -f 忽略警告信息 -i 删除前先询问</span><br><span class="line">rm [选项] 文件</span><br><span class="line">//删除文件夹 </span><br><span class="line">rm -r 目录名</span><br><span class="line"></span><br><span class="line">//重命名</span><br><span class="line">rename libfmt.a libfmt.a.bak libfmt.a</span><br></pre></td></tr></table></figure><h4 id="压缩-解压文件"><a href="#压缩-解压文件" class="headerlink" title="压缩/解压文件"></a>压缩/解压文件</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tar[选项][文件]</span><br><span class="line">//打包并压缩文件，压缩包后缀为 .tar.gz</span><br><span class="line">tar -czvf *.tar.gz</span><br><span class="line">//解压并展开压缩包，压缩包后缀为 .tar.gz</span><br><span class="line">tar -xzvf *.tar.gz</span><br></pre></td></tr></table></figure><p>具体参数参考如下：</p><table><thead><tr><th></th><th></th></tr></thead><tbody><tr><td>参数</td><td>作用</td></tr><tr><td>-c</td><td>创建压缩文件</td></tr><tr><td>-x</td><td>解开压缩文件</td></tr><tr><td>-t</td><td>查看压缩包内有哪些文件</td></tr><tr><td>-z</td><td>用Gzip压缩或者解压</td></tr><tr><td>-j</td><td>用bip2压缩或者解压</td></tr><tr><td>-v</td><td>显示压缩或者解压的过程</td></tr><tr><td>-f</td><td>目标文件名</td></tr><tr><td>-p</td><td>保留原始的权限和属性</td></tr><tr><td>-P</td><td>使用绝对路径来压缩</td></tr><tr><td>-C</td><td>指定解压到的目录</td></tr></tbody></table><p>参考：</p><p><a href="https://blog.csdn.net/m0_46422300/article/details/104645072">Linux 常用操作命令大全（最后更新时间：2021）_Yooao的博客-CSDN博客_linux常用命令</a></p><p><a href="https://zhuanlan.zhihu.com/p/205217949">[Linux]创建新用户及用户权限 - 知乎 (zhihu.com)</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;修改文件操作权限&quot;&gt;&lt;a href=&quot;#修改文件操作权限&quot; class=&quot;headerlink&quot; title=&quot;修改文件操作权限&quot;&gt;&lt;/a&gt;修改文件操作权限&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;命令为 chmod， 有两种操作方式&lt;/strong&gt;，&lt;/p&gt;
&lt;p&gt;一种</summary>
      
    
    
    
    <category term="Linux系统" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>初始化列表</title>
    <link href="http://example.com/2022/03/23/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/"/>
    <id>http://example.com/2022/03/23/%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8/</id>
    <published>2022-03-23T12:50:22.000Z</published>
    <updated>2022-03-23T13:09:52.583Z</updated>
    
    <content type="html"><![CDATA[<h2 id="初始化列表的概念及使用"><a href="#初始化列表的概念及使用" class="headerlink" title="初始化列表的概念及使用"></a>初始化列表的概念及使用</h2><p>C++98中，标准允许使用花括号”{}”对数组元素进行统一的集合初始值设定。比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int arr[5] = &#123;0&#125;;</span><br><span class="line">int arr[] = &#123;1,2,3,4&#125;;</span><br></pre></td></tr></table></figure><p>C++11中，这种初始化的方法，被扩展到了集合（列表）中。</p><p>总结初始化方法如下：<br>1） 等号加上赋值表达式，如 int a = 3+4；<br>2） 等号 加上花括号的 初始化列表， 如 int a = {3+4};<br>3） 圆括号式的表达式列表（expression list）, 如 int a = (3+4);<br>4） 花括号式的初始化列表 ， 如 int a{3+4}</p><p>其中，第3、4中方式也可用于获取堆内存 new操作符中，如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int * i = new int(5);</span><br><span class="line">double *d = new double(1.5f);</span><br></pre></td></tr></table></figure><p>标准模板库中容器对初始化列表的支持源自<initializer_list>这个头文件中initialize_list的类模板的支持。<br>只需要包含这个头文件，并且声明一个以initialize_list<T>模板类为参数的构造函数，同样可以使得自定义的类使用列表初始化。</p><p>利用初始化列表，重载operator[]，operator= 以及使用辅助的数组。例子如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">#include &lt;initializer_list&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Mydata&#123;</span><br><span class="line">public:</span><br><span class="line">    Mydata&amp; operator[](initializer_list&lt;int&gt; l)&#123;</span><br><span class="line">        for(auto i=l.begin();i!=l.end();++i)</span><br><span class="line">            idx.push_back(*i);</span><br><span class="line">       return *this;     </span><br><span class="line">    &#125;</span><br><span class="line">    Mydata&amp; operator=(int v)&#123;</span><br><span class="line">        if(idx.empty()!=true)</span><br><span class="line">        &#123;</span><br><span class="line">            for(auto i = idx.begin();i!=idx.end();++i)</span><br><span class="line">            &#123;</span><br><span class="line">                d.resize((*i&gt;d.size())?*i:d.size());</span><br><span class="line">                d[*i-1] = v;</span><br><span class="line">            &#125;</span><br><span class="line">            idx.clear();</span><br><span class="line">        &#125;</span><br><span class="line">        return *this;</span><br><span class="line">    &#125;</span><br><span class="line">    void print()&#123;</span><br><span class="line">        for(auto i=d.begin();i!=d.end();++i)</span><br><span class="line">            cout&lt;&lt;*i&lt;&lt;&quot; &quot;;</span><br><span class="line">        cout&lt;&lt;endl;    </span><br><span class="line">    &#125;</span><br><span class="line">private:</span><br><span class="line">    vector&lt;int&gt; idx;  //辅助数组，用于记录index</span><br><span class="line">    vector&lt;int&gt; d;    </span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">int main()&#123;</span><br><span class="line">    Mydata d;</span><br><span class="line">    d[&#123;2,3,5&#125;] = 7;   //将第2，3，5位设为7</span><br><span class="line">    d[&#123;1,4,5,8&#125;] = 4; //第1，4，5，8位设为4</span><br><span class="line">    d.print();  //4 7 7 4 7 0 0 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，初始化列表还可以用于函数返回的情况，但是返回一个初始化列表，通常会导致构造一个临时变量</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;int&gt;Func()&#123;</span><br><span class="line">    return &#123;1,3&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="防止类型收窄"><a href="#防止类型收窄" class="headerlink" title="防止类型收窄"></a>防止类型收窄</h2><p>使用列表初始化还有一个最大优势是 可以防止类型收窄。</p><p>类型收窄 一般是指一些可以使得数据变化或者精度丢失的隐式类型转换。</p><p>可能导致 类型收窄的典型情况如下：</p><ol><li><p>以浮点数隐式地转换为整型 比如： int a = 1.2</p></li><li><p>从高精度的浮点数转化为低精度的浮点数，比如： 从long double 隐式地转为 double。或者从double 转为 float。 这种精度降低，都可以视为类型收窄</p></li><li><p>从整型转为浮点数。如果整型数大到无法使用浮点数精确表达，也可以视为类型收窄</p></li><li><p>从整型，转为较低长度地整型。 比如：unsigned char = 1024; 1024是不能被8位地unsigned char 容纳的</p></li></ol><p>使用初始化列表，是不能容许类型收窄的情况出现的。会编译通不过。</p><h2 id="使用自定义初始化列表"><a href="#使用自定义初始化列表" class="headerlink" title="使用自定义初始化列表"></a>使用自定义初始化列表</h2><p>示例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Warriors</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    Warriors(const initializer_list&lt;string&gt;&amp; members)</span><br><span class="line">    &#123;</span><br><span class="line">        for (auto&amp; data : members)</span><br><span class="line">        &#123;</span><br><span class="line">            players.emplace_back(data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    vector&lt;string&gt; players;</span><br><span class="line"></span><br><span class="line">    void print()</span><br><span class="line">    &#123;</span><br><span class="line">        for (auto itm : players)</span><br><span class="line">            std::cout &lt;&lt; itm &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;初始化列表的概念及使用&quot;&gt;&lt;a href=&quot;#初始化列表的概念及使用&quot; class=&quot;headerlink&quot; title=&quot;初始化列表的概念及使用&quot;&gt;&lt;/a&gt;初始化列表的概念及使用&lt;/h2&gt;&lt;p&gt;C++98中，标准允许使用花括号”{}”对数组元素进行统一的集合初始</summary>
      
    
    
    
    <category term="C++11" scheme="http://example.com/categories/C-11/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>Linux多线程服务端编程</title>
    <link href="http://example.com/2022/03/23/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/"/>
    <id>http://example.com/2022/03/23/%E3%80%8ALinux%E5%A4%9A%E7%BA%BF%E7%A8%8B%E6%9C%8D%E5%8A%A1%E7%AB%AF%E7%BC%96%E7%A8%8B%E3%80%8B%E7%AC%94%E8%AE%B0/</id>
    <published>2022-03-23T12:50:22.000Z</published>
    <updated>2022-03-23T13:12:08.493Z</updated>
    
    <content type="html"><![CDATA[<p>1 当一个对象能被多个线程同时看到时，那么这个对象的销毁时机就会变得模糊不清，可能出现多种竞态条件：</p><ul><li>在即将析构一个对象时，从何而知此刻是否有其他线程正在执行该对象的成员函数</li><li>如何保证在执行成员函数期间，对象不会在另一个线程被析构</li><li>在调用某个对象的成员函数之前，如何得知这个对象还活着？它的析构函数会不会碰巧执行到一半？</li></ul><p>解决这些race condtion是C++多线程编程面临的基本问题。可以使用shared_ptr来一劳永逸地解决这些问题。</p><p>2 对象构造要做到线程安全，唯一的要求是构造期间不能泄漏this指针。</p><p>基于此，二段式构造–即构造函数 + initialize() – 有时会是好办法。这种方式虽然不符合C++教条，但是多线程下别无选择。</p><p>3 mutex不能安全地保护析构，因为一旦执行析构，mutex对象也会被销毁。这样，在多线程的情况下，如果其他线程正在使用mutex用到一半，就会有问题。</p><p>4 空悬指针：</p><p>两个指针p1，p2，指向堆里的同一个对象Object，并且p1和p2位于不同的线程中（线程A和线程B）。假设线程A通过p1指针将对象销毁了，那么p2就成了悬空指针。这是一种典型的C/C++内存错误。</p><p>要想安全地销毁对象，最好在别人(即别的线程)都看不到的情况下，偷偷地做。这个也正是垃圾回收(gc)的原理，所有人用不到的一定是垃圾。</p><p>（悬空指针，是指指向的内容已经被释放的指针）</p><p>5 C++里可能出现的内存问题大致有如下几个方面：</p><ul><li>缓冲区溢出 (buffer overrun)</li><li>空悬指针 / 野指针</li><li>重复释放 (double delete)</li><li>内存泄漏 (memory leak)</li><li>不配对的 new[] / delete</li><li>内存碎片 (memory fragment)</li></ul><p>而正确地使用智能指针可以很轻易地解决前5种问题</p><p>6 shared_ptr的拷贝开销要比原始指针的拷贝开销要高（因为拷贝的时候需要修改引用计数，而修改引用计数需要加锁操作）。所以，我们在将shared_ptr作为函数参数传递的时候，尽量使用常引用的形式，这样减少拷贝次数，来减少性能损失。</p><p>7 让this指针，能变身为shared_ptr的方法，是让类继承 enable_shared_from_this。</p><p>8 弱回调：如果对象还活着，就调用它的成员函数，否则忽略之。</p><p>9 read-copy-update</p><p>10 不推荐使用信用量(Semaphore)，原因：</p><ul><li>条件变量配合互斥量可以完全替代其功能，而且更不易出错</li><li>semaphore has no notion of ownership</li><li>信号量有自己的计数值，而通常我们自己的数据结构也有长度值，这就造成了同样的信息存放了两份，需要时刻保持一致，这增加了程序员的负担和出错的可能。</li><li>如果要控制并发度，可以考虑用muduo::ThreadPool</li></ul><p>11 使用 pthread_once 来实现 Singleton</p><p>12 在”non-blocing IO + IO multiplexing” 这种模型（即Reactor模式）中，程序的基本结构是一个事件循环(event loop)， 以事件驱动(event-driven) 和事件回调的方式实现业务逻辑。</p><p>Reactor摸型的优点：</p><p>编程不难，效率也不错。不仅可以用于读写socket，连接的建立，甚至DNS解析都可以用非阻塞的方式进行，以提高并发度和吞吐量，对于IO密集的应用是一个不错的选择。</p><p>缺点：</p><p>它要求事件回调函数必须是非阻塞的。对于涉及网络IO的请求响应式协议，它容易割裂业务逻辑，使其散布于多个回调函数之中，相对不容易理解和维护。</p><p>13 one loop per thread</p><p>libev的作者说：</p><p>One loop per thread is usually a good model. Doing this is almost never wrong, sometimes a better-performance model exists, but it is always a good start.</p><p>这种方式的好处，在于：</p><ul><li>线程数目基本固定，可以在程序启动的时候设置，不会频繁创建与销毁</li><li>可以很方便地在线程之间调配负载</li><li>IO事件发生的线程是固定的，同一个TCP连接不必考虑事件并发</li></ul><p>Eventloop代表了线程的主循环，需要让哪个线程干活，就把timer或IOchannel(如TCP连接)注册到哪个线程的loop里即可。</p><p>对实时性有要求的额connection 可以单独用一个线程；</p><p>数据量大的connection可以独占一个线程，并把数据处理任务分摊到另几个计算线程中（用线程池）；</p><p>其他次要的辅助性connection可以共享一个线程。</p><p>对于具有一定规模的服务端程序，一般就会采用 non-blockong + IO multiplexing， 每个connection/acceptor 都会注册到某个eventloop上，程序里有多个event loop,每个线程至多有一个event loop。</p><p>多线程程序对event loop 提出了更高的要求，那就是“线程安全”。要允许一个线程往别的线程的loop里塞数据，这个loop必须得是线程安全的。</p><p>14 进程间通信首选Sockets(主要是指TCP)，其最大的好处在于：可以跨主机，具有伸缩性。其他优势：</p><ul><li>在编程上，TCP sockets和pipe都是操作文件描述符，用来收发字节流，都可以 read/write/fcntl/poll等。不同的是，TCP是双向的；Linux的pipe是单向的，使用没有TCP方便</li><li>TCP的port是由一个进程独占的，而且操作系会自动回收(listening port 和已建立连接的TCP socket都是文件描述符，在进程结束时操作系统会自动关闭所有文件描述符)。这说明，即使程序意外退出，也不会给系统留下垃圾，程序重启之后就可以比较容易地恢复，而不需要重启操作系统。还有一个好处，既然port是独占的，就可以防止程序重复启动。</li><li>两个进程通过TCP通信，如果一个崩溃了，操作系统会关闭连接，另一个进程就会立刻感知到，可以快速failover（故障转移）。</li><li>与其他IPC相比，TCP的一个天生的好处是“可记录、可重现”。tcpdump和Wireshark 是解决两个进程间协议和状态争端的好帮手，也是性能(吞吐量、延迟等)分析的利器。我们可以借此编写分布式程序的自动化回归测试。还可以用tcpcopy之类的工具进行压力测试。</li><li>TCP还能跨语言，服务端和客户端之间可以不必使用同一种语言</li><li>使用TCP这种字节流方式通信，会有 marshal/unmarshal的开销，这就要求我们选用合适的消息格式，准确的说是 wire format(字节序列？)，推荐用 Google Protocol Buffers</li></ul><p>15 使用TCP长连接的好处有两点：</p><ul><li>容易定位分布式系统中的服务之间的依赖关系。只要在机器上运行 netstat -tpna | grep :port 就能立刻列出用到某服务的客户端地址，然后在客户端的机器上用 netstat 或者 lsof 命令找出是哪个进程发起的连接。</li><li>通过接收和发送队列的长度也比较容易定位网络或者程序故障。</li></ul><p>16 本书对 “服务器开发” 的定义，用一句话形容：</p><p>跑在多核机器上的Linux用户态的没有用户界面的长期运行的 网络应用程序，通常是分布式系统的组成部件。</p><p>17 多线程的适用场景时：提高响应速度，让IO和“计算”相互重叠，降低latency(延迟)。虽然多线程不能提高绝对性能，但是能提高平均响应性能。</p><p>一个程序要做成多线程的，大致要满足：</p><ul><li>有多个CPU可用。单核机器上多线程没有性能优势(但或许能简化并发业务逻辑的实现)</li><li>线程间有共享数据，即内存中的全局状态。</li><li>共享的数据是可以修改的，而不是静态常量表。</li><li>提供非均质的服务。即，事件的响应有优先级差异，我们可以用专门的线程来处理优先级高的事件。防止优先级反转。</li><li>latency 和 throuthput 同样重要，不是逻辑简单的 IO密集或是 CPU密集。换言之，程序是有相当的计算量的</li><li>能scale up(有规模的增长)。 一个好的多线程程序应该能享受增加CPU数目带来的好处，一旦CPU从8核升级到16核，程序能体现出这种升级带来的性能提升</li><li>具有可预测的性能。随着负载增加，性能缓慢下降，超过某个临界点之后会极速下降。线程数目一般不随负载变化。</li><li>多线程能有效地划分责任与功能，让每个线程的逻辑比较简单，任务单一，便于编码。而不是所有逻辑塞到一个event loop中，导致不同类别的事件之间相互影响</li></ul><p>18 多线程服务程序中的线程大致可以分为三类：</p><ul><li>IO线程，这类线程的主循环是IO multiplexing，阻塞地等在 select/poll/epoll_wait 等系统调用上。这类线程也处理定时事件。当然，它的功能不光光是IO，有些简单的计算也可以放入其中，比如消息的编码或者解码等。</li><li>计算线程，这类线程的主循环是 blocingqueue， 阻塞地等在 conditionvariable上。这类线程一般位于 thread pool中。这种线程一般不涉及IO，一般要避免任何阻塞操作</li><li>第三方库所用的线程，比如 logging ，又比如database connection等</li></ul><p>19 Linux 能同时启动多少个线程？</p><p>对于32-bit Linux，一个进程的地址空间是4GB，其中用户态能访问的为3GB左右，而一个线程的默认栈大小是10 MB，简单计算，一个进程大约可以同时启动300个线程。</p><p>对于64-bit系统，线程数目可大大增加</p><p>20 尽管C++03标准没有明说标准库的线程安全性，但</p><ul><li>我们可以遵循一个基本原则：凡是非共享的对象都是彼此独立的，如果一个对象从始至终只被一个线程使用，那么它就是安全的。</li><li>另外一个事实标准是：共享的对象的read-only操作是安全的，前提是不能有并发的写操作。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1 当一个对象能被多个线程同时看到时，那么这个对象的销毁时机就会变得模糊不清，可能出现多种竞态条件：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;在即将析构一个对象时，从何而知此刻是否有其他线程正在执行该对象的成员函数&lt;/li&gt;
&lt;li&gt;如何保证在执行成员函数期间，对象不会在另一个线程被析构</summary>
      
    
    
    
    <category term="C++编程" scheme="http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++学习" scheme="http://example.com/tags/C-%E5%AD%A6%E4%B9%A0/"/>
    
  </entry>
  
  <entry>
    <title>进程与线程</title>
    <link href="http://example.com/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/09/10/%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-09-10T05:47:31.000Z</published>
    <updated>2022-03-23T13:13:32.520Z</updated>
    
    <content type="html"><![CDATA[<p><strong>进程与线程的区别</strong></p><p>当我们把代码编译链接生成后的可执行文件，装载到内存中进行运行，这个运行中的实例就是进程。</p><p>同一个可执行文件，可以有多个进程实例。而且，每个进程之间的内存资源都是相互独立、互不影响的。</p><p>换句话解释就是，进程是操作系统进行资源调度和内存分配的基本单位。</p><p>这些进程独享的资源，包括有代码、打开的文件、堆、栈、存放全局变量的数据段 以及一些内核内部使用的数据，比如运行状态等。</p><p>现代的操作系统都是会并发处理多任务的，所以必然会同时处理多个进程，那就必然需要进行进程的切换。而切换进程，意味着，需要将进程独占的那些资源都进行切换。</p><p>那由于进程管理的资源较多，相对切换的成本开销就较大了。这也是引入线程的概念的原因，线程是进程的一个子任务，是用来作为操作系统进行任务调度的最小单位。</p><p>首先线程是相对进程更轻量级的存在，</p><p>单个进程的线程间共享的资源包括：</p><ul><li>代码段</li><li>全局数据段和静态数据段</li><li>栈区</li></ul><p>理论上，栈区是属于线程是有的。</p><p>但是实际上，不同线程的栈区并没有严格的隔离机制来进行保护。</p><p>因此，如果一个线程拿到来自另一个线程栈帧上的指针，那么该线程就可以改变另一个线程的栈区，也就是说，</p><p>这些线程可以任意膝盖本属于另一个线程中的变量。</p><ul><li>堆区</li><li>打开的文件描述符</li><li>命令行参数</li><li>信号处理函数</li><li>进程ID、进程组ID</li></ul><p>线程独占的资源有：（即线程上下文）</p><ul><li>线程的栈区   栈指针?(用来指向栈顶吗？)</li><li>程序计数器（一种寄存器）</li><li>函数运行使用的寄存器（保存部分局部变量之类）</li><li>TLS(Thread Local Storage)</li></ul><p><a href="https://zhuanlan.zhihu.com/p/352707156">线程间到底共享了哪些进程资源 - 知乎 (zhihu.com)</a></p><p>保存进程的信息的地方 称为PCB，进程控制块。</p><p>保存线程的信息的地方，就是TCB，线程控制块。</p><p>PCB存储的信息包括各种资源信息：内存地址空间信息、所有打开的文件、所有的I/O设备信息，</p><p>此外，还有进程描述符（即进程的标识，进程id），进程的运行状态，对应的用户描述符，各种寄存器的信息，以及进程的优先级（操作系统用来进行调度的算法需要）等信息。</p><p>TCB就相对少一点，除了线程描述符，也会记录对应的进程描述符，还有栈、寄存器等相关信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;进程与线程的区别&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;当我们把代码编译链接生成后的可执行文件，装载到内存中进行运行，这个运行中的实例就是进程。&lt;/p&gt;
&lt;p&gt;同一个可执行文件，可以有多个进程实例。而且，每个进程之间的内存资源都是相互独立、互不影响的。&lt;/p&gt;
&lt;</summary>
      
    
    
    
    <category term="Linux系统" scheme="http://example.com/categories/Linux%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="操作系统" scheme="http://example.com/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>std-function</title>
    <link href="http://example.com/2021/07/30/std-function/"/>
    <id>http://example.com/2021/07/30/std-function/</id>
    <published>2021-07-30T04:25:28.000Z</published>
    <updated>2021-08-02T02:31:37.177Z</updated>
    
    <content type="html"><![CDATA[<p><strong>std::function</strong></p><p>测试实验如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">inline</span> <span class="keyword">namespace</span> test</span><br><span class="line">&#123;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">FuncB</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">FuncC</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_use_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">using</span> funcType = std::function&lt;<span class="built_in"><span class="keyword">int</span></span>(<span class="keyword">int</span>, <span class="keyword">int</span>)&gt;;</span><br><span class="line"></span><br><span class="line">funcType a = [](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">funcType b = FuncB;</span><br><span class="line"></span><br><span class="line">funcType c = <span class="built_in">FuncC</span>();</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; <span class="built_in">a</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; <span class="built_in">b</span>(<span class="number">30</span>, <span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; <span class="built_in">c</span>(<span class="number">30</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果如下：</p><p>a = 7<br>b = 70<br>c = 34</p><p>增加变化，加一个类如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FuncContainer</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(funcType&amp;&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;using void Push(funcType&amp;&amp; func)\n&quot;</span>;</span><br><span class="line">m_contianer.<span class="built_in">emplace_back</span>(std::forward&lt;funcType&gt;(func));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">(funcType&amp; func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;using void Push(funcType&amp; func)\n&quot;</span>;</span><br><span class="line">m_contianer.<span class="built_in">emplace_back</span>(func);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">funcType&amp; <span class="title">Take</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;using funcType&amp; Take(int index)\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> m_contianer[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">vector&lt;funcType&gt; m_contianer;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>测试方法如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_use_function</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">FuncContainer container;</span><br><span class="line">container.<span class="built_in">Push</span>([](<span class="keyword">int</span> x, <span class="keyword">int</span> y) &#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;);</span><br><span class="line">container.<span class="built_in">Push</span>(FuncB);</span><br><span class="line">container.<span class="built_in">Push</span>(<span class="built_in">FuncC</span>());</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> afunc = container.<span class="built_in">Take</span>(<span class="number">0</span>);</span><br><span class="line"><span class="keyword">auto</span> bfunc = container.<span class="built_in">Take</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">auto</span> cfunc = container.<span class="built_in">Take</span>(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;a = &quot;</span> &lt;&lt; <span class="built_in">afunc</span>(<span class="number">3</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;b = &quot;</span> &lt;&lt; <span class="built_in">bfunc</span>(<span class="number">30</span>, <span class="number">40</span>) &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;c = &quot;</span> &lt;&lt; <span class="built_in">cfunc</span>(<span class="number">30</span>, <span class="number">4</span>) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试结果：</p><p>using void Push(funcType&amp;&amp; func)<br>using void Push(funcType&amp;&amp; func)<br>using void Push(funcType&amp;&amp; func)<br>using funcType&amp; Take(int index)<br>using funcType&amp; Take(int index)<br>using funcType&amp; Take(int index)<br>a = 7<br>b = 70<br>c = 34</p><p>实验结论：</p><ol><li> std::function 作为通用的多态函数封装器， std::function 的实例能存储、复制及调用任何可调用 (Callable) 目标——函数、 lambda 表达式、 bind 表达式或其他函数对象，还有指向成员函数指针和指向数据成员指针</li><li> std::function 配合using （或者typedef），可以用来作为容器的元素进行存储</li><li> std::function 作为函数参数传递时，都是作为右值引用来进行传递的</li><li> std::function 重载的 operator= 返回的是引用类型，所以，需要注意其存储元素的生命周期</li></ol><p>参考：</p><p><a href="https://www.apiref.com/cpp-zh/cpp/utility/functional/function.html">std::function - C++中文 - API参考文档 (apiref.com)</a></p><p><a href="http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E">http://note.youdao.com/noteshare?id=06b5f1b1fb45fa8bc1e478a1abf478eb&amp;sub=978CCDA963334F62AAA7713154779E6E</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;std::function&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;测试实验如下：&lt;/p&gt;
&lt;figure class=&quot;highlight c++&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/</summary>
      
    
    
    
    <category term="C++编程" scheme="http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++11" scheme="http://example.com/tags/C-11/"/>
    
  </entry>
  
  <entry>
    <title>C++11线程库使用</title>
    <link href="http://example.com/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2021/07/30/C-11%E7%BA%BF%E7%A8%8B/</id>
    <published>2021-07-30T01:59:29.000Z</published>
    <updated>2021-08-02T02:31:29.105Z</updated>
    
    <content type="html"><![CDATA[<h3 id="c-11线程"><a href="#c-11线程" class="headerlink" title="c++11线程"></a>c++11线程</h3><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p>关于线程池，之前交易网关这边虽然会管理多个线程，但一直没有用到线程池去管理。</p><p>前段时间，给国密的mauth服务器做一个校验账号密码的通讯组件的时候，使用了一个线程处理一个用户的校验的设计，所以尝试着去使用了线程池，</p><p>并且，他们的程序是运行在linux系统的，所以线程池也首次使用了c++11的方法去实现</p><p>c++11新增了线程库，最主要最熟知的应该就是 std::thread，以及配合以线程同步用的std::mutex和std::conditon_variable。</p><p>有了以上三个特性，我们可以很简便的实现一个跨线程的任务队列(BlockingQueue)，这个是实现线程池的基础。</p><p>所以，今天主要先分享下 c++11 线程库使用的一些方法，然后再分享下c++11的线程池实现。</p><h4 id="std-thread"><a href="#std-thread" class="headerlink" title="std::thread"></a>std::thread</h4><h5 id="使用thread库"><a href="#使用thread库" class="headerlink" title="使用thread库"></a>使用thread库</h5><p>最常见的启动一个线程的方法：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(ThreadFunc)</span></span>;</span><br></pre></td></tr></table></figure><p>如果是带参数的线程函数，就可以：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(<span class="keyword">int</span> count)</span></span>&#123;</span><br><span class="line">    <span class="comment">//do something</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(ThreadFunc, <span class="number">5</span>)</span></span>;</span><br><span class="line"><span class="comment">//或者 使用&lt;functional&gt;中提供的 std::bind方法，将参数绑定到对应的线程函数上</span></span><br><span class="line"><span class="function">std::thread <span class="title">t</span><span class="params">(std::bind(ThreadFunc, <span class="number">5</span>))</span></span>;</span><br></pre></td></tr></table></figure><p>交易网关这边，基于std::thread实现了一个ThreadBase的类，来封装线程的启动和停止，可以参考。</p><h5 id="关于线程的结束"><a href="#关于线程的结束" class="headerlink" title="关于线程的结束"></a>关于线程的结束</h5><p>线程启动后，一般需要等到线程函数运行完，线程才能结束</p><p>标准库对于线程的结束也有两种方式：</p><p>1） 在主线程中调用join方法，主线程就会阻塞等待到线程函数运行完，然后结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(t.<span class="built_in">joinable</span>())</span><br><span class="line">    t.<span class="built_in">join</span>()</span><br></pre></td></tr></table></figure><p>2）调用detach方法，将线程从主线程分离。这种形式，主线程不会被阻塞，也不会知道分离出去的线程什么时候结束。</p><p>如果确定主线程肯定比线程函数晚结束，或者线程和主线程的存活时间是一致的，则可以直接在启动线程后，直接detach。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t.<span class="built_in">detach</span>();</span><br><span class="line"><span class="comment">//简便的写法，声明和detach一起调用</span></span><br><span class="line">std::<span class="built_in">thread</span>(ThreadFunc).<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><h5 id="thread启动线程的其他方式"><a href="#thread启动线程的其他方式" class="headerlink" title="thread启动线程的其他方式"></a>thread启动线程的其他方式</h5><p>此外，std::thread启动线程，也可以使用lambda表达式，参考如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">thread</span>([]()&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">20</span>; ++i)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>&gt;(<span class="string">&#x27;A&#x27;</span> + i) &lt;&lt; endl;</span><br><span class="line">this_thread::<span class="built_in">sleep_for</span>(<span class="number">10</span>ms);</span><br><span class="line">&#125;&#125;</span><br><span class="line">           );</span><br></pre></td></tr></table></figure><p>对于将参数为引用的函数来作为线程函数，也有如下两种操作可参考：</p><p>1） 使用lambda表达式，如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">unordered_map&lt;<span class="keyword">int</span>, string&gt; myMapSrc&#123;</span><br><span class="line">&#123;<span class="number">1</span>, <span class="string">&quot;first&quot;</span> &#125;,</span><br><span class="line">&#123;<span class="number">2</span>, <span class="string">&quot;second&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="number">3</span>, <span class="string">&quot;third&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="number">4</span>, <span class="string">&quot;four&quot;</span>&#125;,</span><br><span class="line">&#123;<span class="number">5</span>, <span class="string">&quot;five&quot;</span>&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//捕获列表使用 &amp; 就可以</span></span><br><span class="line">std::<span class="built_in">thread</span>([&amp;myMapSrc]()&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : myMapSrc)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; item.first &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">&#125;&#125;</span><br><span class="line">).<span class="built_in">detach</span>();</span><br></pre></td></tr></table></figure><p>2） 使用std::bind，如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">(unordered_map&lt;<span class="keyword">int</span>, string&gt;&amp; refRec)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; item : refSrc)</span><br><span class="line">&#123;</span><br><span class="line">cout &lt;&lt; <span class="string">&#x27;[&#x27;</span> &lt;&lt; this_thread::<span class="built_in">get_id</span>() &lt;&lt; <span class="string">&quot;]:&quot;</span> &lt;&lt; item.first &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; item.second &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(ThreadFunc, std::<span class="built_in">ref</span>(myMapSrc)));</span><br></pre></td></tr></table></figure><p>由于std::bind总是使用值拷贝的形式传参，哪怕函数声明为引用，std::bind传递的时候也是值传递。所以，标准库提供了std::ref来给std::bind传引用。</p><h4 id="std-async"><a href="#std-async" class="headerlink" title="std::async"></a>std::async</h4><p>标准库，在std::thread的基础上，封装了一些方法，有std::promise，std::pacakged_task，以及std::async。</p><p>这其中，std::promise以及std::pacakged_task的使用，一般还是要配合std::thread以及std::future来。</p><p>这边，比较推荐使用std::async来启动一个线程来执行一个异步任务，简单的示例代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">std::<span class="built_in">async</span>(launch::async, ThreadFunc);</span><br><span class="line"><span class="comment">//带参数，则</span></span><br><span class="line">std::<span class="built_in">async</span>(launch::async, ThreadFunc, param1, param2...);</span><br></pre></td></tr></table></figure><p>std::async 方法有返回值，类型是std::future<T></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">string <span class="title">ThreadFuncStr</span><span class="params">(<span class="keyword">int</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    this_thread::<span class="built_in">sleep_for</span>(<span class="number">1</span>s);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;This is ThreadFuncStr\n&quot;</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">to_string</span>(data);</span><br><span class="line">&#125;</span><br><span class="line">std::future&lt;string&gt; result = std::<span class="built_in">async</span>(launch::async, ThreadFuncStr, <span class="number">100</span>);</span><br><span class="line"><span class="comment">//do some other thing </span></span><br><span class="line">string str = result.<span class="built_in">get</span>();</span><br><span class="line">cout &lt;&lt; str &lt;&lt;endl;</span><br></pre></td></tr></table></figure><p>说明：</p><p>std::async， 如果第一个参数是launch::async，那就是立即启动线程任务，但是线程启动后，不会阻塞当前线程。</p><p>只有在后续调用reuslt.get()的时候，会阻塞，直到线程函数返回需要的结果。</p><p>使用建议：</p><p>推荐std::async，是因为它将thread的概念隐藏到了底层，方法本身就成为了，我就是异步去执行一个任务。</p><p>所以，如果我们一旦碰到需要读写文件或者网络请求这种涉及IO，耗时不确定可能会阻塞当前运行线程的时候，都可以调用async，来启动一个异步任务完成这部分的业务处理。</p><p>另外：</p><p>如果想使用std::thread的形式，也需要获取线程函数执行后的返回值，可以使用packaged_task，简单举例：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="function">std::packaged_task&lt;<span class="title">string</span><span class="params">(<span class="keyword">int</span>)</span>&gt; <span class="title">task</span><span class="params">(ThreadFuncStr)</span></span>;</span><br><span class="line">    std::future&lt;string&gt; async_result = task.<span class="built_in">get_future</span>();</span><br><span class="line">    std::<span class="built_in">thread</span>(std::<span class="built_in">move</span>(task), <span class="number">100</span>).<span class="built_in">detach</span>();</span><br><span class="line">    cout &lt;&lt; async_result.<span class="built_in">get</span>() &lt;&lt; endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>感觉用起来，不如std::async方便，感兴趣的可以自行研究(报考std::promise 也是，它们都有各自的应用场景)。</p><h4 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h4><p>有执行一个异步任务来获取结果的需求，肯定也有不定时执行多个异步任务的需求。</p><p>最典型的就是，服务端处理多个不同用户的业务逻辑的场景：</p><p>1）每个用户的业务处理，一般都需要在自己独立的线程中运行；</p><p>2）线程处理完一个用户的业务逻辑，还可以处理另一个用户的业务逻辑。</p><p>这种情况，就比较适合用线程池了。</p><p>下边就是用C++11标准库实现的线程池的代码：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FixedThreadPool</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="keyword">using</span> FuncTaskType = std::function&lt;<span class="built_in"><span class="keyword">void</span></span>()&gt;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">FixedThreadPool</span>(<span class="keyword">size_t</span> threadCount) :</span><br><span class="line"><span class="built_in">m_ResData</span>(make_shared&lt;ResInfo&gt;())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; threadCount; ++i)</span><br><span class="line">&#123;</span><br><span class="line">std::<span class="built_in">thread</span>(std::<span class="built_in">bind</span>(&amp;FixedThreadPool::ThreadFunc, <span class="keyword">this</span>)).<span class="built_in">detach</span>();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">~<span class="built_in">FixedThreadPool</span>()</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (m_ResData != <span class="literal">nullptr</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="function">std::lock_guard&lt;std::mutex&gt; <span class="title">guard</span><span class="params">(m_ResData-&gt;Mtx)</span></span>;</span><br><span class="line">m_ResData-&gt;IsShutdown = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">m_ResData-&gt;Cv.<span class="built_in">notify_all</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Execute</span><span class="params">(FuncTaskType&amp;&amp; task)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">lock_guard&lt;mutex&gt; <span class="title">guard</span><span class="params">(m_ResData-&gt;Mtx)</span></span>;</span><br><span class="line">m_ResData-&gt;Tasks.<span class="built_in">emplace</span>(std::forward&lt;FuncTaskType&gt;(task));</span><br><span class="line">m_ResData-&gt;Cv.<span class="built_in">notify_one</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ThreadFunc</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="function">unique_lock&lt;mutex&gt; <span class="title">lk</span><span class="params">(m_ResData-&gt;Mtx)</span></span>;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span> (!m_ResData-&gt;Tasks.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">auto</span> currentTask = std::<span class="built_in">move</span>(m_ResData-&gt;Tasks.<span class="built_in">front</span>());</span><br><span class="line">m_ResData-&gt;Tasks.<span class="built_in">pop</span>();</span><br><span class="line">lk.<span class="built_in">unlock</span>();</span><br><span class="line"><span class="built_in">currentTask</span>();</span><br><span class="line">lk.<span class="built_in">lock</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (m_ResData-&gt;IsShutdown)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">m_ResData-&gt;Cv.<span class="built_in">wait</span>(lk);</span><br><span class="line">&#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="literal">true</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ResInfo</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">mutex Mtx;</span><br><span class="line">condition_variable Cv;</span><br><span class="line"><span class="keyword">bool</span> IsShutdown = <span class="literal">false</span>;</span><br><span class="line"><span class="comment">//线程函数任务队列</span></span><br><span class="line">queue&lt;FuncTaskType&gt; Tasks;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">std::shared_ptr&lt;ResInfo&gt; m_ResData;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单解释：</p><ul><li><p>ResInfo 是需要的一些信息，包含线程同步用互斥量和条件变量，线程池的开关，以及存储线程任务的队列</p></li><li><p>ResInfo 使用 shared_ptr 是因为 每个线程都会进行一份拷贝</p></li><li><p>存储队列，使用queue，满足先进先出</p></li><li><p>线程任务，统一使用 函数模板 std::function&lt;void()&gt; ，这样，后续再配合std::bind，就可以执行所有带参数和不带参数的线程函数</p></li><li><p>构造的时候，直接启动对应数量的线程，每个线程的运行都封装在ThreadFunc</p></li><li><p>ThreadFunc 使用unique_lock 一是需要配合条件变量进行wait，</p><p>二是，在将线程任务从队列中取出来之后，就不需要再锁了，可以unlock。</p><p>对于线程池内部的mutex，它用来保护的数据，其实就是线程任务队列，所以将线程任务从队列中取出来之后，这个锁的任务就达成了。</p><p>执行完线程任务，再锁住，是该线程在循环，执行完上一个任务，就会去队列中取下一个任务。</p></li><li><p>Execute方法，顾名思义，就是用来执行任务的。右值引用作为参数进行传递时，会转换成左值，需配合完美转发std::forward使用</p></li><li><p>最后，析构函数，主要是确保开关置为true，启动的线程函数可以正常运行结束。</p></li></ul><p>参考:</p><p><a href="https://blog.csdn.net/chenwh_cn/article/details/116492680">C++11 (三) - std::function、std::bind、std::ref</a></p><p><a href="https://blog.csdn.net/weixin_44862644/article/details/115765250">C++11 std::thread detach()与join()用法总结</a></p><p>《Linux多线程服务端编程》</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;c-11线程&quot;&gt;&lt;a href=&quot;#c-11线程&quot; class=&quot;headerlink&quot; title=&quot;c++11线程&quot;&gt;&lt;/a&gt;c++11线程&lt;/h3&gt;&lt;h4 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;</summary>
      
    
    
    
    <category term="C++编程" scheme="http://example.com/categories/C-%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="C++11" scheme="http://example.com/tags/C-11/"/>
    
  </entry>
  
</feed>
